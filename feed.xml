<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不歸路</title>
  <subtitle>簡煒航的個人部落格</subtitle>
  <id>http://tonytonyjan.net</id>
  <link href="http://tonytonyjan.net"/>
  <link href="http://tonytonyjan.net/feed.xml" rel="self"/>
  <updated>2015-11-05T01:10:00+08:00</updated>
  <author>
    <name>大兜</name>
  </author>
  <entry>
    <title>Ruby SSE Server 動手做</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/11/05/concurrent-ruby/"/>
    <id>http://tonytonyjan.net/2015/11/05/concurrent-ruby/</id>
    <published>2015-11-05T01:10:00+08:00</published>
    <updated>2015-11-05T18:19:02+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">
&lt;p&gt;最近要蓋個 &lt;a href="http://www.wikiwand.com/en/Server-sent_events"&gt;SSE&lt;/a&gt; 服務，筆者因貪一時方便就暫時使用 &lt;a href="https://github.com/puma/puma"&gt;puma&lt;/a&gt; 在 Rails 上實現，但畢竟用執行緒解決長請求是很不妙的行為，這幾天就用 Ruby 開始徒手寫了 I/O multiplexing 伺服器，有種回到學生時代的感覺，只是 Ruby 只有 &lt;code&gt;select()&lt;/code&gt;，少了 &lt;code&gt;epoll()&lt;/code&gt;、&lt;/p&gt;</summary>
    <content type="html">
&lt;p&gt;最近要蓋個 &lt;a href="http://www.wikiwand.com/en/Server-sent_events"&gt;SSE&lt;/a&gt; 服務，筆者因貪一時方便就暫時使用 &lt;a href="https://github.com/puma/puma"&gt;puma&lt;/a&gt; 在 Rails 上實現，但畢竟用執行緒解決長請求是很不妙的行為，這幾天就用 Ruby 開始徒手寫了 I/O multiplexing 伺服器，有種回到學生時代的感覺，只是 Ruby 只有 &lt;code&gt;select()&lt;/code&gt;，少了 &lt;code&gt;epoll()&lt;/code&gt;、&lt;code&gt;kqueue()&lt;/code&gt; 很不方便，好在 &lt;a href="https://github.com/eventmachine/eventmachine"&gt;eventmachine&lt;/a&gt; 背後使用的是 &lt;a href="http://software.schmorp.de/pkg/libev.html"&gt;libev&lt;/a&gt; 和 &lt;a href="https://github.com/libevent/libevent"&gt;libevent&lt;/a&gt;，有用到上述兩個系統調用，但筆者其實是最希望使用 &lt;a href="https://github.com/libuv/libuv"&gt;libuv&lt;/a&gt; 呢（一副要逼人貢獻的節奏啊），另外一個方案是用 &lt;a href="https://github.com/celluloid/celluloid"&gt;celluloid&lt;/a&gt; 替代 &lt;a href="https://github.com/eventmachine/eventmachine"&gt;eventmachine&lt;/a&gt;，但前者在 I/O 的處理上&lt;a href="https://github.com/celluloid/celluloid-io/blob/5e96845e68fdcd406717e3ab543b0099168a1c15/lib/celluloid/io.rb"&gt;仍然使用 &lt;code&gt;Kernel.select()&lt;/code&gt;&lt;/a&gt;，筆者也就作罷。&lt;/p&gt;

&lt;h1 id="rails-"&gt;Rails 即時串流&lt;/h1&gt;

&lt;p&gt;雖然以 Rails 時下的 HTTP server 方案，要做串流服務有點吃力，但要做也是可行的，串流功能在 Rails 4 後才開始支援，controller 需要 mix &lt;code&gt;ActionController::Live&lt;/code&gt; 才可以使用 &lt;code&gt;response.stream&lt;/code&gt;，建議可以參考 tenderlove 在 2012 寫的 &lt;a href="http://tenderlovemaking.com/2012/07/30/is-it-live.html"&gt;Is it live?&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class MyController &amp;lt; ActionController::Base
  include ActionController::Live

  def stream
    response.headers['Content-Type'] = 'text/event-stream'
    100.times {
      response.stream.write "hello world\n"
      sleep 1
    }
  ensure
    response.stream.close
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述程式碼不至於難以理解，頂多注意要記得關掉 stream，否則打開的 socket 會一直開著直到海枯石爛，導致最系統上的檔案描述符被一堆死掉的 socket 佔用。&lt;/p&gt;

&lt;p&gt;大家要更關注的應該是 HTML5 支援的 SSE 功能要怎麼在 Rails 上實現，當然我們可直接徒手寫：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class MyController &amp;lt; ActionController::Base
  include ActionController::Live

  def index
    response.headers['Content-Type'] = 'text/event-stream'
    3.times {
      response.stream.write "event: time\ndata: #{Time.now}\n\n"
    }
  ensure
    sse.close
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;data&lt;/code&gt; 部分是任意的字串，不過大部分的案例我們會使用 JSON，好讓 client 端可以更輕易取得資料，但這樣新版本的寫法會用到許多 &lt;code&gt;Hash#to_json&lt;/code&gt; 或 &lt;code&gt;Array#to_json&lt;/code&gt;，且徒手送出符合 SSE 規格的字串也很不方便，好在 Rails 也有 &lt;code&gt;ActionController::Live::SSE&lt;/code&gt; 可以用：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class MyController &amp;lt; ActionController::Base
  include ActionController::Live

  def index
    response.headers['Content-Type'] = 'text/event-stream'
    sse = SSE.new(response.stream, retry: 300, event: "event-name")
    sse.write({ name: 'John'})
    sse.write({ name: 'John'}, id: 10)
    sse.write({ name: 'John'}, id: 10, event: "other-event")
    sse.write({ name: 'John'}, id: 10, event: "other-event", retry: 500)
  ensure
    sse.close
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ActionController::Live::SSE&lt;/code&gt; 跟 tenderlove 在 2012 寫的版本大同小異，即便是在 Rails 4 上，也是一段不到 40 行的類別，目的是將 &lt;code&gt;#write&lt;/code&gt; 方法包裝，讓本來只能寫入字串的 &lt;code&gt;#write&lt;/code&gt;，變得可以傳入物件（大多情況下是 Hash 或是 Array 物件），片段程式碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;def write(object, options = {})
  case object
  when String
    perform_write(object, options)
  else
    perform_write(ActiveSupport::JSON.encode(object), options)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="rails--http-"&gt;別用 Rails 做 HTTP 推送服務&lt;/h2&gt;

&lt;p&gt;從以前工程師就在苦思如何在有限的運算單位與記憶體之下服務更多的訪客，Rails 的並行性目前已有許多方案，做法不外乎是用執行緒（puma）、行程（unicorn）或者兩者並行（rainbows、puma clustered mode），無論何者，每個連線都會佔用至少一個行程或是執行緒，直到 action 方法執行結束才會釋放資源。&lt;/p&gt;

&lt;p&gt;這種架構適合運算密集的服務，通常一份 HTML 可以在 300ms 內傳輸完畢，I/O 佔用的時間很短，行程或執行緒可以很快被釋放；但如果是 I/O 密集的服務（例如串流服務），由於 I/O 佔用時間長，所以我們通常不會一些像是影片的大檔案放在 Rails 的 action 中去傳輸，而是丟到 public 目錄下或是 S3。&lt;/p&gt;

&lt;p&gt;舉例如果有個影片需要 1 分鐘的下載時間，我們交給 Rails 去處理，且 puma 設定支援 32 個執行緒，那麼同一分鐘內只能有最多 32 人可以看影片，如果你要蓋一個 YouTube 或 RedTube，同一時間只能服務最多 32 人，會很不方便。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;把執行緒限制調高到十萬？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;調高到十萬並不是什麼好事，想像一下，一台機器有上萬個執行緒在跑，但是只有 4 顆處理器是個怎樣的情形，光是上下文交換就可以耗盡資源了，何況好不容易交換到某個執行緒，結果 I/O 太忙，連一個位元組也沒傳到就又被交換走了。&lt;/p&gt;

&lt;p&gt;所以即便在 Rails 做 SSE 是如此容易，筆者也不會建議用 Rails 做 SSE，理由是支援 Rails 的 HTTP 伺服器，無論是 unicorn 或 puma 等皆然，它們每服務一個連線會佔用一個行程或是執行緒造成阻塞，此架構下不適合實作提供長久連線的服務（例如 push server 網路遊戲、聊天室等）。&lt;/p&gt;

&lt;h1 id="io-multiplexing-"&gt;I/O Multiplexing 動手做&lt;/h1&gt;

&lt;p&gt;Ruby 內建相關的系統調用只有 &lt;code&gt;select()&lt;/code&gt;，沒有 &lt;code&gt;epoll()&lt;/code&gt;、沒有 &lt;code&gt;kqueue&lt;/code&gt;，在阻塞方面也只有提供 &lt;code&gt;IO#read_nonblock&lt;/code&gt; 和 &lt;code&gt;IO#write_nonblock&lt;/code&gt;，沒有支援 AIO，在這樣的資源下，選用非同步阻塞的策略也是很合理的，筆者先後用原生 Ruby 做了第一個版本，再用 eventmachine 做了另外一個，程式碼如下：&lt;/p&gt;

&lt;h2 id="kernelselect"&gt;Kernel.select()&lt;/h2&gt;

&lt;p&gt;Ruby 有內建 &lt;code&gt;select()&lt;/code&gt; 系統調用可以使用，但 &lt;code&gt;select()&lt;/code&gt; 最大的弱點是受到 &lt;code&gt;FD_SETSIZE&lt;/code&gt; 的限制，除非重新編譯內核，否則在許多 Linux 發行下預設是 1024，扣掉 server socket，只能服務 1023 個訪客，所以這段程式碼可用於學習，不建議用在產品中：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;require 'socket'

SERVER_SOCKET = TCPServer.new 'localhost', 3310
SOCKETS = [SERVER_SOCKET]

Thread.new do
  loop do
    clients = SOCKETS - [SERVER_SOCKET]
    clients.each do |socket|
      socket.send "event: time\ndata: #{Time.now}\n\n", 0
    end
    sleep 1
  end
end

# I/O loop
loop do
  # 這行是阻塞的，直到有任何一個檔案描述符狀態變成可讀或可寫，內核會主動通知
  ready_to_read, ready_to_write, in_error = select(SOCKETS, [], [])
  ready_to_read.each do |socket|
    case socket
    when SERVER_SOCKET
      client_socket, client_addrinfo = SERVER_SOCKET.accept
      SOCKETS &amp;lt;&amp;lt; client_socket
      puts "connect: #{client_socket}"
    else # 若非 server 即 client socket
      begin
        socket.recv(1024)
        socket.send "HTTP/1.1 200 OK
Server: Ziltag Push Server
Content-Type: text/event-stream
Connection: keep-alive
Access-Control-Allow-Origin: *\n\n", 0
      rescue
        $stderr.puts $!, $@
        SOCKETS.delete(socket)
        puts "disconnect: #{socket}"
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你願意重編內核調高 &lt;code&gt;FD_SET_SIZE&lt;/code&gt;，這個做法是滿足 C10K 的。&lt;/p&gt;

&lt;h1 id="eventmachine"&gt;eventmachine&lt;/h1&gt;

&lt;p&gt;可惜 &lt;code&gt;select()&lt;/code&gt; 有諸多問題讓人們漸漸放棄使用，好在 eventmachine 使用 libevent，會根據作業系統去支援相對的系統調用，在 Linux 選用 &lt;code&gt;epoll()&lt;/code&gt;，在 FreeBSD 選用 &lt;code&gt;kqueue()&lt;/code&gt;，且提供了抽象的介面讓使用者可以輕易實作出 I/O 事件驅動的程式：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;require 'eventmachine'

class PushServer &amp;lt; EM::Connection
  @@clients = []

  def self.clients
    @@clients
  end

  def broadcast msg, slugs
    @@clients.each do |client|
      client.send_data msg
    end
  end

  def post_init
    @@clients &amp;lt;&amp;lt; self
    puts "#{self} connected"
  end

  def receive_data data
    send_data "HTTP/1.1 200 OK
Server: Ziltag Push Server
Content-Type: text/event-stream
Connection: keep-alive
Access-Control-Allow-Origin: *\n\n"
  end

  def unbind
    @@clients.delete(self)
    puts "#{self} disconnected"
  end
end

EventMachine.run do
  EventMachine.add_periodic_timer(1) do
    PushServer.clients.each do |client|
      client.send_data "event: time\ndata: #{Time.now}\n\n"
    end
  end
  EventMachine.start_server '0.0.0.0', 3310, PushServer
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eventmachine 在連線產生時，會去監聽該 socket 描述符，收到資料時會觸發 &lt;code&gt;#receive_data&lt;/code&gt;，比起剛剛的 &lt;code&gt;select()&lt;/code&gt; 實作，使用 eventmachine 會更容易維護，且可以輕易在 I/O 策略上做切換（例如在 &lt;code&gt;EventMachine.run&lt;/code&gt; 之前先執行 &lt;code&gt;EventMachine.epoll&lt;/code&gt;），很方便。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;為何不用 celluloid？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;celluloid 是為了解決 concurrent 問題而存在的，比起 eventmachine，他的應用層面更廣泛，因為在真實世界中遇到的問題不會只有 I/O 要處理，有些計算密集的程式用 thread 也許更有效率，所以 celluloid 的作者決定同時用了執行緒和 I/O multiplexing 兩種技巧去解決所有並行的問題，而 eventmachine 只是 celluloid 的其中一個擴展而已（&lt;a href="https://github.com/celluloid/celluloid-io"&gt;celluloid-io&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;但筆者只是單純寫個 SSE 服務，用 eventmachine 就綽綽有餘了，即便 eventmachine 只用到一顆處理器，但多開幾個伺服器然後反向代理也是可以做到橫向擴展。&lt;/p&gt;

&lt;h1 id="section"&gt;結論&lt;/h1&gt;

&lt;p&gt;Rails 不是萬靈丹，即便支援了串流功能，仍不適合做 I/O 密集的應用，不過 Rails 5 的 Action Cable 是可以期待一下，因為這東西使用的是 eventmachine 和執行緒，很適合用來維持大量的連線，不過這是為了 websocket 而寫，如果是要做 comet 的應用（長請求），最好另尋方法，使用 Rails 恐怕是繞遠路，以 Ruby 的方案來看，著名的專案就屬 eventmachine 與 celluloid。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;或者叛逃到 node 或 go 也行啦&lt;/del&gt;&lt;/p&gt;

&lt;h1 id="section-1"&gt;本文出現的連結&lt;/h1&gt;

&lt;h2 id="section-2"&gt;好文&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://www.wikiwand.com/en/Server-sent_events"&gt;SSE&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://www.slideshare.net/KyleDrake/hybrid-concurrency-patterns"&gt;Hybrid Concurrency Patterns&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/cn/linux/l-async"&gt;使用异步 I/O 大大提高应用程序的性能&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://tenderlovemaking.com/2012/07/30/is-it-live.html"&gt;Is it live?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://www.html5rocks.com/en/tutorials/eventsource/basics"&gt;Stream Updates with Server-Sent Events&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="section-3"&gt;開原專案&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/puma/puma"&gt;puma&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://www.kegel.com/c10k.html"&gt;The C10K Problem&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://software.schmorp.de/pkg/libev.html"&gt;libev&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/eventmachine/eventmachine"&gt;eventmachine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/celluloid/celluloid"&gt;celluloid&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/libevent/libevent"&gt;libevent&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/libuv/libuv"&gt;libuv&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/celluloid/celluloid-io"&gt;celluloid-io&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/rails/actioncable"&gt;actioncable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ruby Conference Taiwan 2015</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/08/06/ruby-conference-taiwan-2015/"/>
    <id>http://tonytonyjan.net/2015/08/06/ruby-conference-taiwan-2015/</id>
    <published>2015-08-06T03:34:00+08:00</published>
    <updated>2015-08-18T18:03:11+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;a href="http://2015.rubyconf.tw/"&gt;&lt;img src="/images/ruby-conf-tw-2015.png" width="100%"&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://2015.rubyconf.tw/"&gt;大會官網&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一年一度的 Ruby Conference 又來啦，今年的明星陣容除了與去年一樣有邀請到 Ruby 之父松本行弘（Matz），Rails 的核心開發者 Aaron Patterson（tenderlove），以及一位來自日本的 CRuby 核心開發者芝田浩（hsbt）。&lt;/p&gt;

&lt;p&gt;大會...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;a href="http://2015.rubyconf.tw/"&gt;&lt;img src="/images/ruby-conf-tw-2015.png" width="100%" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://2015.rubyconf.tw/"&gt;大會官網&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一年一度的 Ruby Conference 又來啦，今年的明星陣容除了與去年一樣有邀請到 Ruby 之父松本行弘（Matz），Rails 的核心開發者 Aaron Patterson（tenderlove），以及一位來自日本的 CRuby 核心開發者芝田浩（hsbt）。&lt;/p&gt;

&lt;p&gt;大會議程主題種類多元，從 Rails 前後端網頁應用到 Ruby 與 C library 的串接都有。如果你對於 Ruby 的效能問題感興趣，可以參考 tka 的「如何用 golang 幫 ruby 專案加速」以及林鈺翔的「Need for Speed: Boost ruby with FFI」，分別應用了不同的程式語言替 Ruby 加速（雖然筆者仍喜歡直接調用 Ruby 的 C API 去寫 C 擴展）。&lt;/p&gt;

&lt;p&gt;此外筆者小投一篇近來對 Rails 前端套件的管理心得，僥倖錄取了，如果你對 Rails 上的前端套件管理有興趣，除了筆者的講題「還給前端工程師一個天空」之外，也建議也可以參考講者何澤清的「gem 'webpack-rails'」，分別使用的技術是 gulp 與 webpack。&lt;/p&gt;

&lt;p&gt;而以國際化為重的 Ruby Conf Taiwan 今年議程也有 13 個國家的開發者投稿議程，將會為聽眾們帶來許多精彩的演說。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rails 購物車設計</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/08/05/design-cart-system-in-rails/"/>
    <id>http://tonytonyjan.net/2015/08/05/design-cart-system-in-rails/</id>
    <published>2015-08-05T21:14:00+08:00</published>
    <updated>2015-10-08T22:24:11+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="" src="/images/cart.png"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;封面圖片為 Minecraft 遊戲的截圖，軌道上的貨車（cart on rails），筆者也算是從 alpha 版就開始玩的老玩家呢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;隨著電子商務的崛起，網站上的購物車系統已經成了普遍的功能，這幾年 Rails 在台灣也快速竄紅，且由 Dave Thomas 與 David Heinemeier...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="" src="/images/cart.png" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;封面圖片為 Minecraft 遊戲的截圖，軌道上的貨車（cart on rails），筆者也算是從 alpha 版就開始玩的老玩家呢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;隨著電子商務的崛起，網站上的購物車系統已經成了普遍的功能，這幾年 Rails 在台灣也快速竄紅，且由 Dave Thomas 與 David Heinemeier Hansson 所著的「&lt;a href="https://pragprog.com/book/rails4/agile-web-development-with-rails-4"&gt;Agile Web Development with Rails 4&lt;/a&gt;」一書中也有購物車範例。即便如此，仍然有許多開發者對於設計真正可用的購物車平台感到挫折。&lt;/p&gt;

&lt;p&gt;其中一個理由是書中對於購物車、訂單、發票等規劃並沒有詳細的介紹，其二則是台灣的第三方支付並沒有任何一家廠商提供足夠友善的 API 供開發者使用。&lt;/p&gt;

&lt;h1 id="section"&gt;購物車系統起手式&lt;/h1&gt;

&lt;p&gt;該如何設計一個購物車系統呢？在思考這個問題前不妨先想想從挑選商品到放入購物車，到最後結帳的過程中，可以切出哪些 entity 以方便規劃資料庫，我們隨即可以直覺的想到有「商品」與「購物車」，而以下就是一個初步的 &lt;a href="https://www.wikiwand.com/en/Entity%E2%80%93relationship_model"&gt;Entity-Relation diagram&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/erd/2.png" /&gt;&lt;/p&gt;

&lt;h2 id="section-1"&gt;保留金額資訊&lt;/h2&gt;

&lt;p&gt;沒道理筆者拿了一罐牛奶，你就只能挑豆漿，所以研判一個購物車可以有多個產品，且一個產品放進多個購物車，而這樣的設計圖乍看完美卻有個問題：試想當一個訪客挑選了一樣產品，並且放入購物車，這時如果該產品的價錢被後台管理員異動，那麼在訪客結帳之前購物車中的商品價錢也需要異動嗎？&lt;/p&gt;

&lt;p&gt;如果這是被允許的，那麼筆者可以在訪客結帳的前一秒，將價錢偷改為幾百萬（之後幾年就是官司人生），於是我們需要新的設計避免這樣的悲劇：&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/erd/3.png" /&gt;&lt;/p&gt;

&lt;p&gt;這樣就好了許多，LineItem（在其他 Rails 的專案中，有的人會將 LineItem 命名為 CartItem）作為關聯 Product 與 Cart 的角色之外，還需額外儲存數量與金額資訊，這個金額必須是該產品加入購物車當下的數字，如此結帳時才不會有爭議價錢異動的爭議。&lt;/p&gt;

&lt;h2 id="section-2"&gt;「訂單」與「購物車」的差異？&lt;/h2&gt;

&lt;p&gt;「訂單」與「購物車」在電子商務系統中扮演的角色相似卻也有些差異，相似是兩者都同樣會記錄訪客加入購物車的商品的當前價錢與數量，差異則是「購物車」可編輯商品資訊（例如數量或新增商品），但「訂單」除了付款之外，不可再異動商品資訊，且「訂單」會擁有更多如地址、姓名、統編等一類的通訊資料。&lt;/p&gt;

&lt;p&gt;加上「訂單」後的設計圖：&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/erd/5.png" /&gt;&lt;/p&gt;

&lt;h2 id="section-3"&gt;付款紀錄&lt;/h2&gt;

&lt;p&gt;「訂單」不能異動，唯一可以執行的動作就是「付款」。可是付款未必每次都會成功，且無論成功與否都應該留個記錄，記錄除了方便管理員查詢、找出問題之外，也能提供給使用者供參考與留存。&lt;/p&gt;

&lt;p&gt;「交易紀錄」不需通訊資料，只需要記錄成功與否、交易編號即可，以下是新的設計圖：&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/erd/7.png" /&gt;&lt;/p&gt;

&lt;p&gt;你大概會注意到 Trade 有個 &lt;code&gt;params:text&lt;/code&gt; 屬性，這是用來存放第三方支付服務所回傳的資料，可能是 JSON 或是 XML 格式，搭配 ActiveRecord 中的 &lt;a href="http://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Serialization/ClassMethods.html#method-i-serialize"&gt;&lt;code&gt;#serialize&lt;/code&gt;&lt;/a&gt;，可以輕易存取這個欄位以供日後的查閱由服務所回傳的原始交易資料。&lt;/p&gt;

&lt;h1 id="section-4"&gt;其他人怎麼做？&lt;/h1&gt;

&lt;p&gt;像購物車系統如此常見的功能，想必也有許多開源項目可以使用，其中最有名的三個專案分別是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/drhenner/ror_ecommerce"&gt;ror_ecommerce&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spreecommerce.com/"&gt;Spree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/piggybak/piggybak"&gt;Piggybak&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="rorecommerce"&gt;ror_ecommerce&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/ror-ecommerce.png" /&gt;&lt;/p&gt;

&lt;p&gt;是由 &lt;a href="https://github.com/drhenner"&gt;David Henner&lt;/a&gt; 在設計一個電子商務系統時，順手開源的項目，並且寫了&lt;a href="http://www.ror-e.com/"&gt;一個網站&lt;/a&gt;解釋他的設計哲學，即便這個項目是三個之中更新最慢的，但對於想學習如何徒手製作電子商務網站的人來說，筆者認為這是最值得參考的學習文件。&lt;/p&gt;

&lt;p&gt;ror_ecommerce 的資料庫設計與本篇文章的示意圖、以及「Agile Web Development with Rails 4」書中的範例相同。&lt;/p&gt;

&lt;h2 id="spree"&gt;Spree&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/spree.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Spree 是 Rails 開源電子商務圈最著名的項目，是由許多資深工程師組成的核心團隊所開發，其中不乏 Apache 軟體協會的成員與公司的 CTO、CEO，品質保證，加上完整的 API、文件以及活絡的社群，此外與 ActiveMerchant 相容性高，對於單純只是想要快速架設電子商務網站的人來說，Spree 堪稱首選。&lt;/p&gt;

&lt;p&gt;資料結構方面，有別於前述的架構，Spree 並沒有 Cart entity，而是在 Order 之中新增一個 &lt;code&gt;state&lt;/code&gt; 屬性將「訂單」偽裝成「購物車」的行為，導致 Order 的行為邏輯比 Cart 複雜，但是可以實現的功能更多。&lt;/p&gt;

&lt;h2 id="piggybak"&gt;Piggybak&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/piggybak.png" /&gt;&lt;/p&gt;

&lt;p&gt;算是 Rails 開源電子商務的後起之秀，沒有 Spree 那樣完備，但其模組化的彈性使得許多開發者也開始投像 Piggybak 的懷抱，這層關係有點像 Paperclip 與 CarrierWave 之間一樣，後者也是以模組化著稱。&lt;/p&gt;

&lt;p&gt;你可以在 Rails 中任何一個 ActiveRecord model 中掛上 &lt;code&gt;acts_as_sellable&lt;/code&gt; 使其成為可以買賣的商品，相當簡便，如果你想要的是在既有的網站上加上購物功能，而非重新打造一個購物網站，也許這是讓你選擇 Piggybak 而非 Spree 的誘因。&lt;/p&gt;

&lt;h1 id="section-5"&gt;結語嗎&lt;/h1&gt;

&lt;p&gt;購物車系統沒有什麼「一定得這樣」的設計，不管是什麼架構的購物車，可以結帳的就是好的購物車。如果對於設計購物車仍有疑惑，也建議不妨多看看他人的開源項目怎麼設計，其實許多書中找不到的答案，都放在程式碼裡面，而優良的程式碼更是可以閱讀的。&lt;/p&gt;

&lt;p&gt;筆者也有一份串接歐付寶的範例網站就放在 &lt;a href="https://github.com/tonytonyjan/brainana_shop"&gt;Github&lt;/a&gt; 上，有興趣的讀者可供參考，當然，也歡迎送 patch =)&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>[台北] 艾斯糖 S Don</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/07/14/s-don/"/>
    <id>http://tonytonyjan.net/2015/07/14/s-don/</id>
    <published>2015-07-14T17:19:00+08:00</published>
    <updated>2015-07-15T08:43:31+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="" src="/images/s-don.png"&gt;&lt;/p&gt;

&lt;p&gt;店名：艾斯糖（S Don）&lt;br&gt;
地址：台北市大安區新生南路一段 97 巷 13 號&lt;br&gt;
網址：&lt;a href="https://www.facebook.com/pages/%E8%89%BE%E6%96%AF%E7%B3%96-S-Don/678897485514918"&gt;https://www.facebook.com/pages/艾斯糖-S-Don/678897485514918&lt;/a&gt;&lt;br&gt;
營業時間：周一 - 周四 10:15 - 20:00；周五 - 周六 10:15 - 21...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="" src="/images/s-don.png" /&gt;&lt;/p&gt;

&lt;p&gt;店名：艾斯糖（S Don）&lt;br /&gt;
地址：台北市大安區新生南路一段 97 巷 13 號&lt;br /&gt;
網址：&lt;a href="https://www.facebook.com/pages/%E8%89%BE%E6%96%AF%E7%B3%96-S-Don/678897485514918"&gt;https://www.facebook.com/pages/艾斯糖-S-Don/678897485514918&lt;/a&gt;&lt;br /&gt;
營業時間：周一 - 周四 10:15 - 20:00；周五 - 周六 10:15 - 21：00；周日 10:15 - 18：00&lt;br /&gt;
SOHO 評價：★★★★☆&lt;/p&gt;

&lt;h2 id="section"&gt;簡介&lt;/h2&gt;

&lt;p&gt;自從筆者把其中一間房間佈置成工作室之後，就已經鮮少在網誌上介紹適合工作的咖啡廳了。然而最近鄰居非常勤勞地在施工裝潢，且早上八點就開始鑽牆，弄的筆者除了被吵醒之外，也無法專心在家工作。只好外出尋覓避難所，所幸找到了這家咖啡廳「艾斯糖」。&lt;/p&gt;

&lt;h2 id="wifi"&gt;WIFI、電源、安靜、不限時&lt;/h2&gt;

&lt;p&gt;&lt;img src="/images/s-don-seats.jpg" width="100%" /&gt;&lt;/p&gt;

&lt;p&gt;這家店就這麼低調的藏在捷運忠孝新生站附近的巷子裡，遠離人車的吵雜，比起鬧區的店要來的安靜許多，且店內除了提供免費的 WIFI 之外，每個座位附近都至少會鄰近一組插座，這讓習慣抱著筆電四處跑的網路工作者與 SOHO 族來說相當的方便，而桌子不至於太小，也適合與隊友們在此做些小討論或開會，除了上述的功能之外，以一個咖啡廳而言也適合平日與好友一起來下午茶。&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-books.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;即便沒有自備讀物，書架上也有許多種類的閒書供取閱，其實不妨偶爾挑個悠閒的午後，在這裡隨機抽一本有緣的書來閱讀，配一杯咖啡，也可以愜意的在這裡度過半天。&lt;/p&gt;

&lt;h2 id="section-1"&gt;貓奴的選擇&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-cat.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;如果你也愛貓，也許可以來和副店長「艾斯」做個朋友，記得筆者與他的第一次的邂逅時，他正慵懶的睡在書架的格子裡。雖然艾斯對於第一次見面的陌生人也許不太理會，但基本上也不太怕生。這天筆者整個下午在店裡寫程式，寫到一半艾斯就跳到腿上，本來應該很溫馨的，可惜寫程式需要非常專注的腦力，所以筆者是被嚇到的XD&lt;/p&gt;

&lt;p&gt;這裡總共有兩隻貓，經店員解釋，在假日才有機會遇到另一隻野生的喵星人，好奇的朋友不妨可以挑假日來拜訪。&lt;/p&gt;

&lt;h2 id="section-2"&gt;不定期的小活動&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-dolls.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;這家店的空間利用也頗多元，時有不定期的展演活動或手工藝教學，種類應有盡有，如上圖即是某次「週六小學堂」的主題：襪子娃娃。此外店裡也提供投影設備，經過預約即可使用，所以除了上述一般手工藝或是靜態的展覽之外，在此辦小講座、讀書會抑或電影欣賞也不會是問題。而筆者也考慮也許下一場 Taipei.rb 可以辦在這裡。&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-represent.png" /&gt;&lt;/p&gt;

&lt;h2 id="section-3"&gt;食物&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-food.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;價位方面，低消是一杯飲料，每個餐點無論飲品或食物大多落在 100 至 200 元之間。&lt;/p&gt;

&lt;p&gt;食物方面，無奈筆者舌頭不太敏感，向來對食物不敢妄下點評，但經過筆者的強者朋友表示這裡的拿鐵非常好喝且順口，對咖啡有研究的人說不定可以來此驗證看看。&lt;/p&gt;

&lt;p&gt;值得一提的是這家店的菜單是「活」的，有季節限定的限量的手工點心，看起來也有在推陳出新，所以無論你是常客還是過客，每次來訪並不至於失去新鮮感。&lt;/p&gt;

&lt;h2 id="section-4"&gt;總評&lt;/h2&gt;

&lt;p&gt;來就對了XD&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>平凡人出國夢</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/07/03/dream-of-traveling-abroad/"/>
    <id>http://tonytonyjan.net/2015/07/03/dream-of-traveling-abroad/</id>
    <published>2015-07-03T16:43:00+08:00</published>
    <updated>2015-07-03T17:02:18+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="" src="/images/okinawa.jpg"&gt;&lt;/p&gt;

&lt;p&gt;六月去了一趟沖繩，這是第一次不是因為工作或是演講而出國，保持多年的「從沒出國玩過」的紀錄就這麼被破除了，高興之餘卻有些小可惜，畢竟再不能以炫耀式的語氣聲稱自己出國從沒有花過錢了。&lt;/p&gt;

&lt;p&gt;遙想兒時出國對筆者而言曾是高不可攀的夢想呢，那時全家都沒有人出過國，畢竟這種娛樂對家裡來說是個不小的負擔。幸...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="" src="/images/okinawa.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;六月去了一趟沖繩，這是第一次不是因為工作或是演講而出國，保持多年的「從沒出國玩過」的紀錄就這麼被破除了，高興之餘卻有些小可惜，畢竟再不能以炫耀式的語氣聲稱自己出國從沒有花過錢了。&lt;/p&gt;

&lt;p&gt;遙想兒時出國對筆者而言曾是高不可攀的夢想呢，那時全家都沒有人出過國，畢竟這種娛樂對家裡來說是個不小的負擔。幸運的是筆者在高二時投入了台北一個基金會的培訓計劃，紀錄一年以來所做的社區關懷服務，且得到了前往新加坡與萊佛士書院（聽說是新加坡的建中）學生交流的機會。那是筆者的第一次，也是整個家裡第一次有個人可以飛出台灣島看看外面的世界，那時心裡真的覺得可以光宗耀祖了。&lt;/p&gt;

&lt;p&gt;後來上了大學，因有幸得以回去基金會幫忙，又一次以小領隊的身份，帶著相隔幾屆的學弟妹飛往新加坡做交流。在此之後就沒有什麼出去的機會，加上大四開始成了家裡的經濟支柱，實在不敢有什麼昂貴的娛樂。這四年一度很羨慕身旁同學寒暑假可以四處出國玩，同時無奈自己成績在競爭激烈的校園中無法申請交換學生。&lt;/p&gt;

&lt;p&gt;現在出社會也有幾年，收入漸趨穩定，但也許是舊習所遷，即便過去所認為的昂貴在現在看似平價，心裡頭仍有幾分疙瘩，畢竟過去省習慣了，這錢實在花不下去，就連國內的著名景點也沒去過幾個，有駕照卻也沒車，由此斷定筆者是休閒界的麻瓜不為過。&lt;/p&gt;

&lt;p&gt;倒是這幾年透過投搞國際議程，筆者出國的機會漸漸變多，由於旅費、住宿大多由大會支出，筆者不用負擔太多經費，也省下不少錢，這似乎是個不錯的出國方式。缺點是機票可能是由大會決定，所以無法安排太彈性的旅程，且大多時間其實要做演講的準備，並不會花太多時間在娛樂上，實在難以放開心去玩。&lt;/p&gt;

&lt;p&gt;直到因緣際會之下認識了一位人氣探險家，帶著麻瓜筆者去沖繩玩，才首次體驗到放開心情去玩的感覺，整趟旅程真的很開心。雖然途中筆者曾出現些&lt;del&gt;可能屬於工程師的&lt;/del&gt;脫線舉動，現在回憶起來還是非常感謝這位耐心體貼的探險家，陪我共度美好的沖繩之旅。&lt;/p&gt;

&lt;p&gt;同時此程也解除了許多第一次成就呢，包括潛水（這輩子沒潛過水，第一次就是獻給日本）、參加 Okinawa.rb（整個會場的電腦都是 Google Translator 其實很有趣啊）、觀賞海豚秀等。想必是永生難忘，特以此文紀念。&lt;/p&gt;

&lt;p&gt;至於出遊照片與遊記，且看筆者心情了XD&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>台灣身份證字號驗證器</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/04/15/national-identification-card-validator-of-taiwan/"/>
    <id>http://tonytonyjan.net/2015/04/15/national-identification-card-validator-of-taiwan/</id>
    <published>2015-04-15T18:30:00+08:00</published>
    <updated>2015-04-15T20:21:22+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;今天在 Ruby Taiwan 的 &lt;a href="https://www.facebook.com/groups/142197385837507/permalink/888110727912832/"&gt;FB 社團上&lt;/a&gt;看到 adz 大大在問是否有身份證字號驗證的 gem 可以用。&lt;/p&gt;

&lt;p&gt;這東西記得在大一時用 C、Java 各寫過一次，程式碼已遺失，反正今天寫了一天程式也累了，只好寫別的程式來放鬆一下（啥？），不過這次會用 Ruby 來寫，同樣的程式碼我也放在 &lt;a href="https://gist.github.com/tonytonyjan/361282d5b6771660b88c"&gt;Gist&lt;/a&gt;&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;今天在 Ruby Taiwan 的 &lt;a href="https://www.facebook.com/groups/142197385837507/permalink/888110727912832/"&gt;FB 社團上&lt;/a&gt;看到 adz 大大在問是否有身份證字號驗證的 gem 可以用。&lt;/p&gt;

&lt;p&gt;這東西記得在大一時用 C、Java 各寫過一次，程式碼已遺失，反正今天寫了一天程式也累了，只好寫別的程式來放鬆一下（啥？），不過這次會用 Ruby 來寫，同樣的程式碼我也放在 &lt;a href="https://gist.github.com/tonytonyjan/361282d5b6771660b88c"&gt;Gist&lt;/a&gt; 上面：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;MAP = {
  'A' =&amp;gt; [1, 0], 'B' =&amp;gt; [1, 1], 'C' =&amp;gt; [1, 2], 'D' =&amp;gt; [1, 3], 'E' =&amp;gt; [1, 4], 'F' =&amp;gt; [1, 5], 'G' =&amp;gt; [1, 6], 'H' =&amp;gt; [1, 7], 'I' =&amp;gt; [3, 4],
  'J' =&amp;gt; [1, 8], 'K' =&amp;gt; [1, 9], 'L' =&amp;gt; [2, 0], 'M' =&amp;gt; [2, 1], 'N' =&amp;gt; [2, 2], 'O' =&amp;gt; [3, 5], 'P' =&amp;gt; [2, 3], 'Q' =&amp;gt; [2, 4], 'R' =&amp;gt; [2, 5],
  'S' =&amp;gt; [2, 6], 'T' =&amp;gt; [2, 7], 'U' =&amp;gt; [2, 8], 'V' =&amp;gt; [2, 9], 'W' =&amp;gt; [3, 2], 'X' =&amp;gt; [3, 0], 'Y' =&amp;gt; [3, 1], 'Z' =&amp;gt; [3, 3]
}
 
MULTIPLIER = [1, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1]
 
def id_check id
  return false unless id =~ /\A[A-Z]\d{9}\z/
  chars = id.chars
  numbers = MAP[chars.shift] + chars.map!(&amp;amp;:to_i)
 
  sum, i = 0, 0
  while i &amp;lt; 11
    sum += numbers[i] * MULTIPLIER[i]
    i += 1
  end
  sum % 10 == 0
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;寫完後還不免想要比較一下別人的 code，不料也能意外的比網路上僅存的兩個 gem 快兩倍以上：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;require 'benchmark'
require 'id_check'
require 'taiwanese_id_builder'
require 'TaiwanUserID'
 
n = 100000
Benchmark.bmbm do |x|
  x.report('wayne5540  '){ n.times{ TaiwaneseIdBuilder.valid?('A123456789') } }
  dummy = Object.new.extend(TaiwanUserID)
  x.report('kaochenlong'){ n.times{ dummy.is_valid?('A123456789') } }
  x.report('tonytonyjan'){ n.times{ id_check('A123456789') } }
end
 
# wayne5540     1.080000   0.230000   1.310000 (  1.319509)
# kaochenlong   1.860000   0.010000   1.870000 (  1.879476)
# tonytonyjan   0.550000   0.000000   0.550000 (  0.557314)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="while-"&gt;while 無敵&lt;/h2&gt;

&lt;p&gt;筆者只知道 Ruby 中的迭代方法，無論用 &lt;code&gt;#each&lt;/code&gt; 還是 &lt;code&gt;#times&lt;/code&gt;，沒有一個比 &lt;code&gt;while&lt;/code&gt; 還要快的，所以果斷用了 &lt;code&gt;while&lt;/code&gt; 來解題，但這題其實要幾兩個陣列相乘再做加總，其實可以用 &lt;code&gt;#zip&lt;/code&gt; 甚至是 Ruby 內建的 &lt;code&gt;Matrix&lt;/code&gt; 來做。&lt;/p&gt;

&lt;p&gt;正想做 benchmark 時就搜尋到&lt;a href="http://stackoverflow.com/questions/7372489/whats-the-efficient-way-to-multiply-two-arrays-and-get-sum-of-multiplied-values"&gt;這篇文章&lt;/a&gt;，所以果然還是 &lt;code&gt;while&lt;/code&gt; 無敵啊XD。&lt;/p&gt;

&lt;p&gt;對高效能的 Ruby 有興趣的人可以參考 Juanito Fatas 的 &lt;a href="https://github.com/JuanitoFatas/fast-ruby"&gt;fast-ruby&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id="section"&gt;其他人怎麼寫&lt;/h2&gt;

&lt;p&gt;在&lt;a href="https://github.com/wayne5540/taiwanese_id_builder/blob/master/lib/taiwanese_id_builder.rb"&gt;這裡&lt;/a&gt;可以找到 wayne5540 的程式碼，其中最令人糾結的是有一個 &lt;code&gt;puts&lt;/code&gt; 沒有拿掉，所以在執行 &lt;code&gt;#valid?&lt;/code&gt; 時會把結果印到螢幕上。所以要是像筆者一樣寫了 benchmark，自然是噴的整個螢幕都是。&lt;/p&gt;

&lt;p&gt;有趣的是筆者意外在 rubygems.org 找到高見龍的 &lt;a href="https://rubygems.org/gems/TaiwanUserID"&gt;gem&lt;/a&gt;，從時間上看是 2013 年 2 月推上來的，且 GitHub 上面找不到，也許是用在教學時寫的。&lt;/p&gt;

&lt;p&gt;裡面只有一個 32 行的檔案，比起 wayne5540 的 gem 要輕巧許多，但也不難看出是效能是怎麼被影響的：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;require "TaiwanUserID/version"

module TaiwanUserID
  def is_valid?(id)
    cities = {
      :A =&amp;gt; '10', :B =&amp;gt; '11', :C =&amp;gt; '12', :D =&amp;gt; '13',
      :E =&amp;gt; '14', :F =&amp;gt; '15', :G =&amp;gt; '16', :H =&amp;gt; '17',
      :I =&amp;gt; '34', :J =&amp;gt; '18', :K =&amp;gt; '19', :L =&amp;gt; '20',
      :M =&amp;gt; '21', :N =&amp;gt; '22', :O =&amp;gt; '35', :P =&amp;gt; '23',
      :Q =&amp;gt; '24', :R =&amp;gt; '25', :S =&amp;gt; '26', :T =&amp;gt; '27',
      :U =&amp;gt; '28', :V =&amp;gt; '29', :W =&amp;gt; '32', :X =&amp;gt; '30',
      :Y =&amp;gt; '31', :Z =&amp;gt; '33',
    }

    id_array = id.upcase.split('')

    special = cities[id_array.first.to_sym][0].to_i * 1 + cities[id_array.first.to_sym][1].to_i * 9
    sum =
      special +
      id_array[1].to_i * 8 +
      id_array[2].to_i * 7 +
      id_array[3].to_i * 6 +
      id_array[4].to_i * 5 +
      id_array[5].to_i * 4 +
      id_array[6].to_i * 3 +
      id_array[7].to_i * 2 +
      id_array[8].to_i * 1 +
      id_array[9].to_i

    return sum % 10 == 0
  end
end
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
</feed>
