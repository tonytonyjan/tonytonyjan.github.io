<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不歸路</title>
  <subtitle>簡煒航的個人部落格</subtitle>
  <id>https://tonytonyjan.net</id>
  <link href="https://tonytonyjan.net"/>
  <link href="https://tonytonyjan.net/feed.xml" rel="self"/>
  <updated>2019-09-23T16:44:00+08:00</updated>
  <author>
    <name>大兜</name>
  </author>
  <entry>
    <title>在 canvas 繪製 JPEG 圖片後保留 EXIF 資訊</title>
    <link rel="alternate" href="https://tonytonyjan.net/2019/09/23/keep-exif-after-drawing-jpeg-image-to-canvas/"/>
    <id>https://tonytonyjan.net/2019/09/23/keep-exif-after-drawing-jpeg-image-to-canvas/</id>
    <published>2019-09-23T16:44:00+08:00</published>
    <updated>2019-09-23T18:10:18+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">
&lt;p&gt;筆者近來開發 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API"&gt;canvas&lt;/a&gt; 相關的應用，發現繪製後的圖片會遺失 EXIF 資訊，於是花了點時間研究 JPEG 檔案格式的規格，並在此將解法分享出來。&lt;/p&gt;

</summary>
    <content type="html">
&lt;p&gt;筆者近來開發 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API"&gt;canvas&lt;/a&gt; 相關的應用，發現繪製後的圖片會遺失 EXIF 資訊，於是花了點時間研究 JPEG 檔案格式的規格，並在此將解法分享出來。&lt;/p&gt;



&lt;p&gt;這個問題應該不難搜尋到&lt;a href="https://stackoverflow.com/questions/18297120/html5-resize-image-and-keep-exif-in-resized-image"&gt;這篇 Stack Overflow 上的討論串&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;只不過 Martin Perry 的&lt;a href="http://www.perry.cz/files/ExifRestorer.js"&gt;在 2013 的做法&lt;/a&gt;有些老舊，筆者重新用 2019 已知的技術翻新了版本。僅使用 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob"&gt;Blob&lt;/a&gt; 和 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"&gt;ArrayBuffer&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id="問題描述"&gt;問題描述&lt;/h1&gt;

&lt;p&gt;在 canvas 上繪製 JPEG 圖片，處理後再將 canvas 輸出新的 JPEG 圖片，同時保留 EXIF 資訊。&lt;/p&gt;

&lt;h1 id="demo"&gt;Demo&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://codepen.io/tonytonyjan/project/editor/XEkOkv"&gt;Keep EXIF Data after Drawing JPEG Image in Canvas&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://gist.github.com/tonytonyjan/ffb7cd0e82cb293b843ece7e79364233"&gt;copyExif.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id="解釋"&gt;解釋&lt;/h1&gt;

&lt;p&gt;直覺上，第一時間想到的做法會是先讀取 EXIF 後再重新寫入。其中讀取 EXIF 方面首選 &lt;a href="https://github.com/exif-js/exif-js"&gt;exif-js&lt;/a&gt;，但寫入 EXIF 方面就不是這麼容易找到成熟的專案，若非年久失修，就是使用的人太少，可能有很多尚未發現的問題。&lt;/p&gt;

&lt;p&gt;然而需求若只是單純要保存原本的 EXIF，而非逐一寫入，其實不需要用到像 exif-js 這麼大的專案。因為 JPEG 檔案的裡面的元資料其實像貨櫃一樣，一個個整齊地存放在名為 marker 的資料結構裡，而其中一個 marker 專門存放 EXIF 資訊。只要將其複製下來，並在新的 JPEG 圖片裡貼上，那麼新的圖片就可以完整保留原始圖片的 EXIF。&lt;/p&gt;

&lt;h1 id="jpeg-marker-結構"&gt;JPEG Marker 結構&lt;/h1&gt;

&lt;p&gt;每一個 JPEG marker 結構如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Marker&lt;/th&gt;
      &lt;th&gt;大小&lt;/th&gt;
      &lt;th&gt;資料&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FFXX&lt;/td&gt;
      &lt;td&gt;SSSS&lt;/td&gt;
      &lt;td&gt;DDDD&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;marker 的標頭都以兩個位元表示，格式以 &lt;code&gt;FFXX&lt;/code&gt; 的形式出現，而接著 marker 後的 2 個位元 &lt;code&gt;SSSS&lt;/code&gt; 則表示後面的資料結構的大小，格式為大端序（big-endian），而該數字所表達的大小包含了 &lt;code&gt;SSSS&lt;/code&gt; 所佔用 2 個位元。&lt;/p&gt;

&lt;p&gt;舉例：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FF C1 00 0C DD DD ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FFC1&lt;/code&gt; 表示 marker 標頭，&lt;code&gt;000C&lt;/code&gt; 表示資料結構大小為 12，但 12 包含了 &lt;code&gt;000C&lt;/code&gt; 本身，所以後面的 &lt;code&gt;DD DD ...&lt;/code&gt; 只有 10 個位元。&lt;/p&gt;

&lt;h1 id="copyexifjs"&gt;copyExif.js&lt;/h1&gt;

&lt;p&gt;EXIF 資訊存放在 APP1 marker 裡面，標頭為 &lt;code&gt;FFE1&lt;/code&gt;，這個檔案的實際操作如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;讀取來源 blob，搜尋 &lt;code&gt;FFE1&lt;/code&gt; 標頭，將整段 APP1 marker 擷取出來。&lt;/li&gt;
  &lt;li&gt;取得 canvas 的 blob。&lt;/li&gt;
  &lt;li&gt;將取得到的 APP1 marker 嵌入 canvas blob 裡面的正確位置。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果有任何問題或覺得寫的哪裡不好，希望能到 &lt;a href="https://gist.github.com/tonytonyjan/ffb7cd0e82cb293b843ece7e79364233"&gt;gist&lt;/a&gt; 給筆者一些指點，感激不盡。&lt;/p&gt;

&lt;h1 id="參考資料"&gt;參考資料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Exif"&gt;Exif - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://www.media.mit.edu/pia/Research/deepview/exif.html"&gt;Exif file format - MIT Media Lab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>男生女生慼 - 適合兩對情侶的桌遊</title>
    <link rel="alternate" href="https://tonytonyjan.net/2019/02/09/a-board-game-for-double-dating/"/>
    <id>https://tonytonyjan.net/2019/02/09/a-board-game-for-double-dating/</id>
    <published>2019-02-09T15:14:00+08:00</published>
    <updated>2019-09-23T18:05:18+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;「男生女生慼」是筆者在某次與朋友雙約會的時候為了打發時間所想出來遊戲。內容跟猜謎類似且準備容易，規則也相當簡單，適合兩到三對情侶出遊時的空檔遊玩。&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;「男生女生慼」是筆者在某次與朋友雙約會的時候為了打發時間所想出來遊戲。內容跟猜謎類似且準備容易，規則也相當簡單，適合兩到三對情侶出遊時的空檔遊玩。&lt;/p&gt;



&lt;h2 id="準備物品"&gt;準備物品&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;情侶 2 對&lt;/li&gt;
  &lt;li&gt;紙卡 40 張（推薦便條紙，如果沒有也可用 5 張 A4 大小的紙摺 3 次，也會有 40 張紙卡）&lt;/li&gt;
  &lt;li&gt;筆 1 支&lt;/li&gt;
  &lt;li&gt;帽子 1 頂（或隨意一個適合丟紙卡的容器）&lt;/li&gt;
  &lt;li&gt;啤酒（選備，但如果有當然會更好）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="前置作業"&gt;前置作業&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;分成 2 個隊伍，一對情侶為一個隊伍，其中一人同時為主持人。&lt;/li&gt;
  &lt;li&gt;將紙卡平分，每人 10 張。&lt;/li&gt;
  &lt;li&gt;每人拿出 2 張紙卡，其中一張寫下考男生的問題，另一張寫下考女生的問題，這 2 張不能讓任何人看到。這些問題必須盡量難倒對手，但也盡量不能難倒自己的夥伴。以下列舉幾個問題：
    &lt;ul&gt;
      &lt;li&gt;女生的生日是今年幾月幾日？&lt;/li&gt;
      &lt;li&gt;男生最喜歡吃的食物是？&lt;/li&gt;
      &lt;li&gt;女生最喜歡的國家？&lt;/li&gt;
      &lt;li&gt;男生的身高是幾公分？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;問題盡量發揮各種想像力添增趣味，甚至可以塗鴉讓人猜是什麼，或是寫下令人感到羞恥的問題。&lt;/li&gt;
  &lt;li&gt;每人將寫好的 2 張紙卡折好丟進帽子裡，最後搖一搖帽子。&lt;/li&gt;
  &lt;li&gt;這時帽子裡面會有 8 張問題紙卡，而每個人手中也分別有 8 張空白紙卡，遊戲可以準備開始。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="遊戲開始"&gt;遊戲開始&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;主持人從帽中抽出一張問題卡並朗誦，丟棄該卡片，不放回帽子。&lt;/li&gt;
  &lt;li&gt;所有人針對這個問題，將問題的答案寫在一張自己的紙卡上，不能讓任何人看到。&lt;/li&gt;
  &lt;li&gt;等所有人都寫好答案且確定不再修改，這時主持人宣布所有人公布自己的答案。&lt;/li&gt;
  &lt;li&gt;主持人檢視兩隊之間的答案，如果兩兩相同，該隊拿到 2 分，差一點或對一半拿到 1 分，完全不同則無分。&lt;/li&gt;
  &lt;li&gt;主持人重複 1 至 3 步驟，直到帽中的 8 張問題卡皆已抽完。&lt;/li&gt;
  &lt;li&gt;經過 8 個回合後遊戲結束，結算總分。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="後記"&gt;後記&lt;/h2&gt;

&lt;p&gt;「男生女生慼」其中的「慼」是小時候遊戲「黑白慼，男生女生配」裡面的「慼」，發音是 tshueh，注音唸起來像「ㄘㄟˋ」，有討厭的意思。&lt;/p&gt;

&lt;p&gt;原本這遊戲是沒有名字的，筆者也不知道怎麼取名，但在遊玩的過程中，當看到男生答不出女生的生日時的那副天怒人怨的窘境，不難理解為何筆者將這個遊戲取名「男生女生慼」（笑）。&lt;/p&gt;

&lt;p&gt;因為雙約會的次數不太多，筆者其實只有玩過一次，如果對於這遊戲有什麼反饋，歡迎留言。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>cron 如何忽略系統的環境變數</title>
    <link rel="alternate" href="https://tonytonyjan.net/2018/07/08/how-cron-omit-environment-variables/"/>
    <id>https://tonytonyjan.net/2018/07/08/how-cron-omit-environment-variables/</id>
    <published>2018-07-08T14:57:00+08:00</published>
    <updated>2018-09-14T09:20:41+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;這大概是碼農們時常會遇到的問題之一了，明明設定好的環境變數在殼層操作沒有問題，但是同樣的指令在 cron 卻會出現找不到該指令或找不到環境變數的錯誤。&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;這大概是碼農們時常會遇到的問題之一了，明明設定好的環境變數在殼層操作沒有問題，但是同樣的指令在 cron 卻會出現找不到該指令或找不到環境變數的錯誤。&lt;/p&gt;



&lt;h1 id="cron-的環境變數去哪了"&gt;cron 的環境變數去哪了？&lt;/h1&gt;

&lt;p&gt;為了偵錯，這時筆者通常會在 cron 腳本設定：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* * * * * env &amp;gt; /var/log/env.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;靜待一分鐘後觀察 &lt;code&gt;/var/log/env.log&lt;/code&gt; 的內容，以決定要補上那些缺漏的環境變數。&lt;/p&gt;

&lt;p&gt;筆者將以類似這樣技巧來重現問題與實驗，並且透過以下 &lt;code&gt;Dockerfile&lt;/code&gt; 作為基礎：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-dockerfile"&gt;FROM debian:stretch-slim
RUN echo 'deb-src http://deb.debian.org/debian stretch main' &amp;gt;&amp;gt; /etc/apt/sources.list
RUN apt-get update
RUN apt-get install -y procps cron vim dpkg-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="問題重現"&gt;問題重現&lt;/h1&gt;

&lt;p&gt;透過 &lt;code&gt;docker run -e FOO=BAR&lt;/code&gt; 可以將環境變數 &lt;code&gt;FOO=BAR&lt;/code&gt; 設定在 Docker container 的 init 程序，由於 init 程序是 UN*X 啟動時開天闢地的第一個程序，其他的程序都是由此程序衍生出來，所以除非做了特別設定，否則所有程序能繼承到 &lt;code&gt;FOO&lt;/code&gt; 環境變數。&lt;/p&gt;

&lt;p&gt;讓我們驗證一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -e FOO=BAR IMAGE_NAME env
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=20794784a3ce
FOO=BAR
HOME=/root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我們可以看到 &lt;code&gt;FOO=BAR&lt;/code&gt; 確實傳進去了，接著，我們再用 cron 做另外一個實驗：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -e FOO=BAR IMAGE_NAME sh -c 'echo \'* * * * * env &amp;gt; /var/log/env.log\' | crontab - &amp;amp;&amp;amp; cron &amp;amp;&amp;amp; sleep $((62 - $(date +%S) )) &amp;amp;&amp;amp; cat /var/log/env.log'
HOME=/root
LOGNAME=root
PATH=/usr/bin:/bin
SHELL=/bin/sh
PWD=/root
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;sleep $((62 - $(date +%S) ))&lt;/code&gt; - 指的是「睡到秒針到 2」。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;從印出的結果發現，同樣是 &lt;code&gt;env&lt;/code&gt; 指令，在殼層執行與 cron 執行的結果並不一致。首先 &lt;code&gt;FOO=BAR&lt;/code&gt; 消失了，甚至 &lt;code&gt;PATH&lt;/code&gt; 裡的路徑也差異極大，從原本的 &lt;code&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&lt;/code&gt; 變成僅剩下 &lt;code&gt;/usr/bin:/bin&lt;/code&gt;，這可以說明為何許多人在 cron 腳本中使用指令時，習慣使用絕對路徑，或者在腳本上方定義明確定義 &lt;code&gt;PATH&lt;/code&gt; 變數。&lt;/p&gt;

&lt;h2 id="cron-的-forking-過程"&gt;cron 的 forking 過程&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;那麼 cron 是在哪個階段把環境變數清掉的呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由於筆者深受「知其然不知其所以然」的痛苦，不得不調查 cron 到底在搞什麼鬼。在此推薦一個好用的指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sh"&gt;ps wwefxo pid,ppid,command
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ww&lt;/code&gt; - 無視終端機的寬度，將結果都印出&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e&lt;/code&gt; - 印出環境變數&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;f&lt;/code&gt; - 以樹狀的方式呈現&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;x&lt;/code&gt; - 印出不被任何終端所控制的程序，例如守護行程&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;o pid,ppid,command&lt;/code&gt; - 只印出程序的 pid、ppid、command&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多用法請參考 &lt;a href="https://linux.die.net/man/1/ps"&gt;man ps&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用同樣的技巧再作一次實驗：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -e FOO=BAR IMAGE_NAME sh -c 'echo \'* * * * * ps wwefxo pid,ppid,command &amp;gt; /var/log/ps.log\' | crontab - &amp;amp;&amp;amp; cron &amp;amp;&amp;amp; sleep $((62 - $(date +%S) )) &amp;amp;&amp;amp; cat /var/log/ps.log'
  PID  PPID COMMAND
    1     0 sh -c echo '* * * * * ps wwefxo pid,ppid,command &amp;gt; /var/log/ps.log' | crontab - &amp;amp;&amp;amp; cron &amp;amp;&amp;amp; sleep $((62 - $(date +%S) )) &amp;amp;&amp;amp; cat /var/log/ps.log PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=87736bfa1426 FOO=BAR HOME=/root
   11     1 cron HOSTNAME=87736bfa1426 HOME=/root PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin FOO=BAR PWD=/
   14    11  \_ CRON HOSTNAME=87736bfa1426 HOME=/root PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin FOO=BAR PWD=/
   15    14      \_ /bin/sh -c ps wwefxo pid,ppid,command &amp;gt; /var/log/ps.log SHELL=/bin/sh HOME=/root PATH=/usr/bin:/bin LOGNAME=root
   16    15          \_ ps wwefxo pid,ppid,command HOME=/root LOGNAME=root PATH=/usr/bin:/bin SHELL=/bin/sh PWD=/root
   13     1 sleep 57 HOSTNAME=87736bfa1426 HOME=/root PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin FOO=BAR PWD=/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可見當 cron 執行一份工作項目時，整體程序的祖孫結構如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init -&amp;gt; cron -&amp;gt; cron -&amp;gt; sh -&amp;gt; cron job
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cron 會額外再 fork 一次自己，然後再執行 &lt;code&gt;sh -c "JOB STRING"&lt;/code&gt;，而環境變數正是在這個階段消失的。&lt;/p&gt;

&lt;p&gt;截至目前為止我們僅知道執行 &lt;code&gt;sh&lt;/code&gt; 時，環境變數已經被改變，無法說明為何環境變數會莫名奇妙消失。筆者起初猜測是 cron 有使用 &lt;code&gt;env -i&lt;/code&gt; 指令，但從程序樹的結果來看則不然。&lt;/p&gt;

&lt;p&gt;無計可施，只好翻了一下 cron 的原始碼，在 &lt;code&gt;do_command.c&lt;/code&gt; 找到了線索：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -e FOO=BAR -w /usr/src -v (pwd)/src:/usr/src IMAGE_NAME apt-get source cron
$ grep -C 3 --color '"-c"' (find src -name do_command.c)
                            }
                        }
#endif
                        execle(shell, shell, "-c", e-&amp;gt;cmd, (char *)0, jobenv);
                        fprintf(stderr, "%s: execle: %s\n", shell, strerror(errno));
                        _exit(ERROR_EXIT);
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原來 cron 在執行 &lt;code&gt;sh&lt;/code&gt; 指令時，使用了 &lt;code&gt;execle&lt;/code&gt;，且在最後的參數傳入了自訂的環境變數 &lt;code&gt;jobenv&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;引用一段 &lt;code&gt;execle&lt;/code&gt; 的 &lt;code&gt;man&lt;/code&gt; 頁面：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The execle() and execvpe() functions allow the caller to specify the environment of the executed program via the argument envp. The envp argument is an array of pointers to null-terminated strings and must be terminated by a NULL pointer. The other functions take the environment for the new process image from the external variable environ in the calling process.  - https://linux.die.net/man/3/execle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然後於是筆者在 &lt;code&gt;entry.c&lt;/code&gt; 找到了設定環境變數的地方&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep -B 2 --color 'env_set' (find src -name entry.c)
        if (!env_get("SHELL", e-&amp;gt;envp)) {
                snprintf(envstr, MAX_ENVSTR, "SHELL=%s", _PATH_BSHELL);
                if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
--
        if (!env_get("HOME", e-&amp;gt;envp)) {
                snprintf(envstr, MAX_ENVSTR, "HOME=%s", pw-&amp;gt;pw_dir);
                if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
--
        if (!env_get("PATH", e-&amp;gt;envp)) {
                snprintf(envstr, MAX_ENVSTR, "PATH=%s", _PATH_DEFPATH);
                if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
--
        }
        snprintf(envstr, MAX_ENVSTR, "%s=%s", "LOGNAME", pw-&amp;gt;pw_name);
        if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
--
#if defined(BSD)
        snprintf(envstr, MAX_ENVSTR, "%s=%s", "USER", pw-&amp;gt;pw_name);
        if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分別設定了 &lt;code&gt;SHELL&lt;/code&gt;、&lt;code&gt;HOME&lt;/code&gt;、&lt;code&gt;PATH&lt;/code&gt; 和 &lt;code&gt;LOGNAME&lt;/code&gt;，這 4 的變數和上述用 &lt;code&gt;ps&lt;/code&gt; 所觀測的環境變數，&lt;code&gt;SHELL=/bin/sh HOME=/root PATH=/usr/bin:/bin LOGNAME=root&lt;/code&gt;，其結果是完全吻合的。&lt;/p&gt;

&lt;p&gt;至此，真相大白。&lt;/p&gt;

&lt;h1 id="後記"&gt;後記&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;本文中的 cron 指的是大多數人所使用的 vixie cron，如果是 busybox 的實作則不會出現這個問題，在 busybox 裡面，cron 工作的程序環境變數會繼承父程序。&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ruby 自動載入器</title>
    <link rel="alternate" href="https://tonytonyjan.net/2018/04/22/ruby-autoloader/"/>
    <id>https://tonytonyjan.net/2018/04/22/ruby-autoloader/</id>
    <published>2018-04-22T16:23:00+08:00</published>
    <updated>2018-04-23T09:42:27+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;軟體在載入模組的方式，可大致分為兩種：消極載入（lazy loading） 與積極載入（eager loading）&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。顧名思義，消極載入是指軟體在啟動時僅載入少數需要的模組，而在執行過程如果有需要其他模組時，再載入該需要的模組；反之積極載入則是在軟體啟動時，積極地將所有的模組載入。&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;軟體在載入模組的方式，可大致分為兩種：消極載入（lazy loading） 與積極載入（eager loading）&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。顧名思義，消極載入是指軟體在啟動時僅載入少數需要的模組，而在執行過程如果有需要其他模組時，再載入該需要的模組；反之積極載入則是在軟體啟動時，積極地將所有的模組載入。&lt;/p&gt;



&lt;p&gt;兩者各有優缺點，一般會在消極載入由於啟動速度快，常用在開發環境（development environment）中，缺點則是軟體運作過程中，對於首次執行的任務，因得加上載入的時間導致效率較差，這在生產環境（production environment）不見得是好事。所以在消極載入的設計下，有些人會在部署時加上一道暖身（warn up）的步驟，以部署一台網頁伺服器為例，可能會在部署後送出各種超文本傳輸協定的請求到上線伺服器，以被動的方式使其可以預先載入所需的模組。積極載入的優缺點則相反：運行快但啟動慢，所以一般會用在生產環境。&lt;/p&gt;

&lt;p&gt;一個比較現代的開發方式是針對載入模組的工作額外設計一個載入器，這個載入器可以在積極或消極兩者間做切換，以在開發環境中使用消極載入，生產環境中使用積極載入。&lt;/p&gt;

&lt;h1 id="const_missing-vs-moduleautoload"&gt;const_missing v.s. Module.autoload&lt;/h1&gt;

&lt;p&gt;&lt;a href="http://guides.rubyonrails.org/autoloading_and_reloading_constants.html"&gt;Rails Guide 有一個篇章&lt;/a&gt;詳細介紹了 Rails 內部載入的方法。內文提到 Rails 在消極載入的實作並沒有使用到 Ruby 內建的 &lt;code&gt;Module.autoload&lt;/code&gt;，取而代之則是用 &lt;code&gt;const_missing&lt;/code&gt; 來實作。&lt;/p&gt;

&lt;p&gt;雖然使用 ActiveSupport 的載入器可以省不少麻煩，但筆者沒有需要用到像是熱重載這類進階功能，加上覺得 &lt;code&gt;const_missing&lt;/code&gt; 效能上並沒有比用 &lt;code&gt;Module.autoload&lt;/code&gt; 實作來的好，只是到底會慢多少？筆者寫了一個基準測試（benchmark test）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;# frozen_string_literal: true

require 'bundler/setup'
require 'benchmark'
require 'fileutils'
require 'active_support' # v5.2.0
require_relative 'autoloader'

n = 10000
words = (?a..?z).to_a.permutation(5).lazy.map(&amp;amp;:join).first(n)
class_names = words.map(&amp;amp;:capitalize)
FileUtils.rm_rf %w[as al]
FileUtils.mkdir_p 'as/foo'
FileUtils.mkdir_p 'al/bar'
words.each do |word|
  IO.write "as/foo/#{word}.rb", "module Foo; module #{word.capitalize} end end"
  IO.write "al/bar/#{word}.rb", "module Bar; module #{word.capitalize} end end"
end

Benchmark.bm(13) do |x|
  ActiveSupport::Dependencies.autoload_paths = ['as']
  x.report('ActiveSupport') do
    class_names.each do |class_name|
      eval "Foo::#{class_name}"
    end
  end

  IO.write 'al/bar.rb', 'module Bar; include Autoloader end'
  require_relative 'al/bar'
  x.report('Autoloader') do
    class_names.each do |class_name|
      eval "Bar::#{class_name}"
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;autoloader&lt;/code&gt; 是筆者另外寫的載入器，載入的檔案是動態產生的，分別放在 &lt;code&gt;as&lt;/code&gt; 和 &lt;code&gt;al&lt;/code&gt; 資料夾，&lt;code&gt;as&lt;/code&gt; 裡的檔案給 ActiveSupport 載入，&lt;code&gt;al&lt;/code&gt; 裡的則以筆者的自製的載入器載入。&lt;/p&gt;

&lt;p&gt;再來看看結果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user     system      total        real
ActiveSupport  16.810000   1.320000  18.130000 ( 18.128572)
Autoloader      1.170000   0.630000   1.800000 (  1.804112)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起來 Autoloader 大約比 ActiveSupport 的版本要快上 10 倍。以下是 &lt;code&gt;autoloader.rb&lt;/code&gt; 的原始碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;module Autoloader
  def self.included(mod)
    caller_path, = caller(1..1).first.partition(':')
    pattern = "#{File.dirname(caller_path)}/#{File.basename(caller_path, '.rb')}/*.rb"
    Dir.glob(pattern).each do |path|
      class_name = File.basename(path, '.rb').split('_').map(&amp;amp;:capitalize).join.to_sym
      mod.autoload class_name, path
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="筆者的-autoloader-的慣例"&gt;筆者的 Autoloader 的慣例&lt;/h1&gt;

&lt;p&gt;筆者的 Autoloader 雖然以效能為出發點，但使用上有些限制。由於它沒有像是 ActiveSupport 會自動將資料夾轉為 module 的&lt;del&gt;魔法&lt;/del&gt;功能（例如有個空的資料夾 &lt;code&gt;foo/bar&lt;/code&gt;，當引用 &lt;code&gt;Foo::Bar&lt;/code&gt; 時，即便沒有 &lt;code&gt;foo/bar.rb&lt;/code&gt;，&lt;code&gt;module Bar; end&lt;/code&gt; 也會自動產生），所以針對每個層級的資料夾，都需要有一個同級同名的檔案來定義名稱空間，例如以下的檔案結構為例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lib
├── myapp
│   ├── adapters
│   │   ├── foo.rb
│   │   ├── bar.rb
│   │   └── buz.rb
│   ├── adapters.rb
│   ├── entities
│   │   ├── foo.rb
│   │   ├── bar.rb
│   │   └── buz.rb
│   ├── entities.rb
│   ├── interactors
│   │   ├── foo.rb
│   │   ├── bar.rb
│   │   └── buz.rb
│   └── interactors.rb
└── myapp.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而其中 &lt;code&gt;adapters&lt;/code&gt; 資料夾相對應 &lt;code&gt;adapters.rb&lt;/code&gt; 原始碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;module Myapp
  module Adapters
    include Autoloader
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同於：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;module Myapp
  module Adapters
    autoload :Foo, "#{__dir__}/foo.rb"
    autoload :Bar, "#{__dir__}/bar.rb"
    autoload :Buz, "#{__dir__}/buz.rb"
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="積極載入"&gt;積極載入&lt;/h1&gt;

&lt;p&gt;筆者尚未對 Autoloader 於生產環境做過優化，但理論上不至於太困難，一個作法是在 &lt;code&gt;autoloader.rb&lt;/code&gt; 裡面可以加入環境變數來判斷如何載入：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;if ENV['MYAPP_ENV'] == 'production'
  Kernel.require path
else
  mod.autoload class_name, path
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在 &lt;code&gt;Autoloader&lt;/code&gt; 模組裡面提供載入方法的介面：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class Foo
  include Autoloader
  ENV['MYAPP_ENV'] == 'production' ? eager_load! : lazy_load!
end
&lt;/code&gt;&lt;/pre&gt;

&lt;div class="footnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1"&gt;
      &lt;p&gt;也有翻譯叫「惰性載入」、「懶載入」，另一邊則稱「熱情載入」等，但筆者認為兩者概念應該透過「消極」與「積極」這樣的翻譯最能融入當地的用語且能一目了然。 &lt;a href="#fnref:1" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>我的貓 - 黏黏和歲歲</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/12/29/my-cat/"/>
    <id>https://tonytonyjan.net/2016/12/29/my-cat/</id>
    <published>2016-12-29T16:58:00+08:00</published>
    <updated>2018-04-22T16:49:27+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;似乎從來沒有介紹過家裡的貓，索性來出賣幾張照片吧！&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161110.jpg" alt=""&gt;&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;似乎從來沒有介紹過家裡的貓，索性來出賣幾張照片吧！&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161110.jpg" alt="" /&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src="/images/cats/20160911-2.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20160911.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161203.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161027.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161004.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161007.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;筆者自 2015 十月開始認養第一隻貓咪，2016 六月認養第二隻，由於從小到大沒有養寵物的經驗，不知從和開始，前三個月不是四處問人就是不斷上網找資料。好在中途之家的姊姊很熱心，總是親切地回答我的問題。&lt;/p&gt;

&lt;h2 id="飲食"&gt;飲食&lt;/h2&gt;

&lt;p&gt;因為知道了近幾年台灣開始吹起了濕食風，遂一開始就沒有打算買乾飼料，就先從三餐吃罐頭開始。試過了顛峰、鈕翠寶、Goody 等等。最後是顛峰的口性最好，雖然顛峰不便宜，當時筆者才養一隻貓，負擔尚可，但第二隻住進來後有些吃緊，筆者也開始找其他濕食管道。&lt;/p&gt;

&lt;p&gt;後來知道台灣有幾家廠商有在做寵物生食，像是汪喵、巴夫等，索性買了一條回家嘗試，不料家裡主子愛吃到把整個碗舔地乾乾淨淨，筆者心喜之下果斷買了幾箱。&lt;/p&gt;

&lt;p&gt;就這樣，她們之後都吃生肉，回歸原始的飲食，而不是加工過的罐頭。&lt;/p&gt;

&lt;h2 id="健康"&gt;健康&lt;/h2&gt;

&lt;p&gt;只有姊姊黏黏看過病，剛來筆者家裡第一天就發燒了。初養前十天就要照顧病貓，這對第一次養寵物的人來說實在是一件很困難的事，但也因此筆者在剛養貓的第一個禮拜就學會了投藥的技能，記得第一次投藥前看了十幾部 YouTube 教學影片，就怕自己做錯一步，害到了黏黏。&lt;/p&gt;

&lt;h2 id="娛樂"&gt;娛樂&lt;/h2&gt;

&lt;p&gt;本來以為只要是逗貓棒就可以吸引貓咪，但好像還是得看個性才行。歲歲會為了彩帶棒瘋狂，但黏黏對貓草娃娃比較感興趣，這讓筆者每次選購玩具都會考慮買到兩種以上。&lt;/p&gt;

&lt;p&gt;根據觀察，貓似乎無法分辨棉被和床中間有一層空間，或是無法理解筆者蓋上被子是什麼概念，每次筆者埋進一隻手在棉被裡搓出一點聲音，她們就會開始隔著棉被狩獵筆者的手，好氣又好笑。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;養寵物真的事很棒的一件事，尤其是對獨居太久的人，加上如果工作性質又屬於 SOHO 的話，長久下來真的會生病，有個寵物陪在身邊，生活也比較不會憂鬱。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby#open 知多少？</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/06/15/comparison-of-ruby-open/"/>
    <id>https://tonytonyjan.net/2016/06/15/comparison-of-ruby-open/</id>
    <published>2016-06-15T00:12:00+08:00</published>
    <updated>2018-04-22T16:49:27+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文同步發表於 &lt;a href="https://blog.alphacamp.co/2016/06/30/ruby-open/"&gt;alphacamp&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/io.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;先來個快問快答吧：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果現在要你使用 Ruby 去開檔，你會想到怎麼做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直覺是使用 &lt;code&gt;File.open&lt;/code&gt;，但想想 &lt;code&gt;File.new&lt;/code&gt; 似乎也可行，然後又發現不使用 &lt;code&gt;File&lt;/code&gt; 類別，直接用 &lt;code&gt;open&lt;/code&gt; 也能做到一樣的事。去查了 Ruby 文件結果...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;strong&gt;本文同步發表於 &lt;a href="https://blog.alphacamp.co/2016/06/30/ruby-open/"&gt;alphacamp&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/io.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;先來個快問快答吧：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果現在要你使用 Ruby 去開檔，你會想到怎麼做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直覺是使用 &lt;code&gt;File.open&lt;/code&gt;，但想想 &lt;code&gt;File.new&lt;/code&gt; 似乎也可行，然後又發現不使用 &lt;code&gt;File&lt;/code&gt; 類別，直接用 &lt;code&gt;open&lt;/code&gt; 也能做到一樣的事。去查了 Ruby 文件結果發現 &lt;code&gt;IO.open&lt;/code&gt; 和 &lt;code&gt;IO.new&lt;/code&gt; 也能做到同樣的操作。&lt;/p&gt;

&lt;p&gt;如你所見，使用 Ruby 光是開個&lt;a href="https://zh.wikipedia.org/zh-tw/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"&gt;檔案描述符&lt;/a&gt;（以下簡稱 FD）就有數幾種方法，令人眼花撩亂，常看到的是有人用同一招打天下，卻一直沒有去了解其他的方法與其是用情境，有些可惜，而這篇文章將透過由下而上的方式，一一介紹、示範它們的差別和使用。&lt;/p&gt;

&lt;h1 id="ionew"&gt;IO.new&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;IO&lt;/code&gt; 類別是 Ruby 對 FD 進行讀寫操作的一切基礎，我們可以用 &lt;code&gt;File&lt;/code&gt; 來操作是因為 &lt;code&gt;File&lt;/code&gt; 繼承自 &lt;code&gt;IO&lt;/code&gt;，只是稍嫌麻煩些。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IO.new&lt;/code&gt; 的第一個參數必須是 FD，或在 Windows 下則稱 &lt;a href="https://zh.wikipedia.org/zh-hant/%E5%8F%A5%E6%9F%84"&gt;句柄&lt;/a&gt;，無論何者都只是一個數字。&lt;/p&gt;

&lt;p&gt;如果你已知標準輸入與標準輸出的檔案描述符分別為 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt;，不妨實驗一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;stdin = IO.new(0)
stdout = IO.new(1)
stdout.puts "what's your name?"
name = stdin.gets.chomp!
stdout.puts "hello, #{name}!"

# what's your name?
# tony
# hello, tony!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外可用 &lt;code&gt;IO.sysopen&lt;/code&gt; 來取得檔案的 FD，這其實就是 &lt;code&gt;File&lt;/code&gt; 類別的做法，&lt;code&gt;File&lt;/code&gt; 只是隱藏此細節罷了：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;fd = IO.sysopen('file.txt', 'w') #=&amp;gt; 3
io = IO.new(fd)
io.puts 'hello!'
io.close
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一個例子是透過 &lt;code&gt;/dev/tty&lt;/code&gt; 寫到終端：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;fd = IO.sysopen('/dev/tty', 'w')
io = IO.new(fd,'w')
puts 'Hello'
io.puts 'World'
io.close

# Hello
# World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;筆者在這裡提醒要小心選擇正確的 tty 檔案，萬一不慎選到其他使用者的，執行上述程式碼就會在他人的終端畫面上印出一堆垃圾。&lt;/p&gt;

&lt;p&gt;如果對 tty 的概念不熟悉，可以參考&lt;a href="http://tldp.org/HOWTO/Text-Terminal-HOWTO-7.html"&gt;這篇文章&lt;/a&gt;，在 UN*X 的世界裡面，所有裝置都是一個檔案，終端也是一個檔案，自然可以像檔案一樣對其進行讀寫。&lt;/p&gt;

&lt;h1 id="ioopen"&gt;IO.open&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;IO.open&lt;/code&gt; 沒什麼新奇之處，它只是 &lt;code&gt;IO.new&lt;/code&gt; 加上 block 的擴充版本，若無使用 block 時，與 &lt;code&gt;IO.new&lt;/code&gt; 無異，最後會回傳 &lt;code&gt;IO&lt;/code&gt; 物件；但若與 block 使用，有兩個特點：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;IO&lt;/code&gt; 物件會在 block 結束時被自動關閉（意即不需要寫 &lt;code&gt;IO#close&lt;/code&gt;）。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IO.open&lt;/code&gt; 最後回傳的不再是 &lt;code&gt;IO&lt;/code&gt; 物件，而是 block 的最後執行結果。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id="iopopen"&gt;IO.popen&lt;/h1&gt;

&lt;p&gt;有曾好奇過市面上的 CI 是怎麼做到即時顯示終端上的文字嗎？以 Travis CI 為例，下圖那塊黑色區塊中的內容是即時輸出的：&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/travis.png" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;或者曾想過在自己的網站上執行外部的指令，並且即時呈現給使用者呢？若你有在 Ruby 中呼叫其他系統指令的經驗（例如 &lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;cat&lt;/code&gt;、&lt;code&gt;bundle install&lt;/code&gt; 等等），那應該對 &lt;code&gt;system&lt;/code&gt;、&lt;code&gt;%x{}&lt;/code&gt; 或是 &lt;code&gt;``&lt;/code&gt; 不陌生：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;system 'date' # =&amp;gt; true, false or nil
%x{date}      # =&amp;gt; the standard output of the running cmd
`date`        # =&amp;gt; as above
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而 &lt;code&gt;system&lt;/code&gt; 只根據指令執行結果成功與否回傳布林值，無法直接存取子程序輸出的結果；&lt;code&gt;%x{}&lt;/code&gt; 會以字串形式回傳結果，但必須等到子程序執行結束後才會回傳整個字串，無法即時監控子程序的標準輸出。&lt;/p&gt;

&lt;p&gt;相較於 &lt;code&gt;%x{}&lt;/code&gt; 回傳完整的字串，&lt;code&gt;IO.popen&lt;/code&gt; 則是回傳 &lt;code&gt;IO&lt;/code&gt; 物件。為了比較出差異，這裡就拿 &lt;code&gt;ping&lt;/code&gt; 指令為例，因為該指令會不斷在終端畫面上輸出訊息，直到使用者手動停止，如果使用 &lt;code&gt;%x{}&lt;/code&gt; 的話，Ruby 程式將會卡在該處，且因準備要回傳的字串越來越長，最後導致記憶體不夠用或程式會卡到海枯石爛。&lt;/p&gt;

&lt;p&gt;相較下操作 &lt;code&gt;IO&lt;/code&gt; 物件就可以一次讀一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;# puts %x{ping www.alphacamp.co} # don't do this
io = IO.popen('ping www.alphacamp.co')
while line = io.gets
  print line
end
# PING www.alphacamp.co (198.41.206.122): 56 data bytes
# 64 bytes from 198.41.206.122: icmp_seq=0 ttl=58 time=2.794 ms
# 64 bytes from 198.41.206.122: icmp_seq=1 ttl=58 time=4.876 ms
# 64 bytes from 198.41.206.122: icmp_seq=2 ttl=58 time=7.081 ms
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;當然這還離真正做出一個在網頁上呈現終端執行畫面的功能還很遠，例如上述的程式碼卡在一個無窮迴圈裡面，&lt;br /&gt;
你可能會想針對 IO 阻塞問題做出一些改善，像是配合 &lt;code&gt;IO.select&lt;/code&gt; 或是 &lt;code&gt;IO#read_nonblock&lt;/code&gt; 等，但純屬延伸議題，不在本章範圍，有機會筆者會在另一篇章中分享怎麼做到 :)&lt;/p&gt;

&lt;h1 id="filenew-與-fileopen"&gt;File.new 與 File.open&lt;/h1&gt;

&lt;p&gt;這兩個方方法就是大家耳熟能詳的開檔方案了，它們和 &lt;code&gt;IO.new&lt;/code&gt; 與 &lt;code&gt;IO.open&lt;/code&gt; 幾乎一樣，只差在覆寫了 &lt;code&gt;initialize&lt;/code&gt; 方法，使其接受的參數不再是 FD 而是檔案的路徑字串。&lt;code&gt;File.new&lt;/code&gt; 回傳值也和 &lt;code&gt;IO.new&lt;/code&gt; 一樣是 &lt;code&gt;IO&lt;/code&gt; 物件；在 &lt;code&gt;File.open&lt;/code&gt; 與 block 同時使用的情況下也和 &lt;code&gt;IO.open&lt;/code&gt; 一樣，會自動關檔，且回傳 block 的最後執行結果。&lt;/p&gt;

&lt;h1 id="kernelopen"&gt;Kernel.open&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Kernel.open&lt;/code&gt; 大概是最萬用的方法了，留在最後講是因為它是 &lt;code&gt;IO.popen&lt;/code&gt; 與 &lt;code&gt;File.open&lt;/code&gt; 的合體，除此也接受擁有 &lt;code&gt;#to_open&lt;/code&gt; 方法的物件。&lt;/p&gt;

&lt;p&gt;當傳入一個物件給 &lt;code&gt;Kernel.open&lt;/code&gt; 時，處理的優先續如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;檢查該物件是否有 &lt;code&gt;#to_open&lt;/code&gt; 方法，有則直接呼叫以取得 &lt;code&gt;IO&lt;/code&gt; 物件。&lt;/li&gt;
  &lt;li&gt;如果物件是字串且開頭是 &lt;code&gt;|&lt;/code&gt;，則去掉 &lt;code&gt;|&lt;/code&gt;，剩下丟給 &lt;code&gt;IO.popen&lt;/code&gt; 處理。&lt;/li&gt;
  &lt;li&gt;最後交給 &lt;code&gt;File.open&lt;/code&gt; 處理&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="to_open"&gt;to_open&lt;/h2&gt;

&lt;p&gt;關於 &lt;code&gt;#to_open&lt;/code&gt; Ruby 文件上沒有一處提及，只記載在 Ruby 原始碼中。實作的時候必要回傳 &lt;code&gt;IO&lt;/code&gt; 物件即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class Foo
  def to_open
    puts 'Foo#to_open is here'
    File.open('test.txt') # =&amp;gt; IO instance
  end
end

open Foo.new do |io|
  # ...
  # io will be closed automatically
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="該用哪個"&gt;該用哪個？&lt;/h1&gt;

&lt;p&gt;這沒有什麼強制的規範，畢竟 Ruby 是一個自由的程式語言，比較接近 Perl，和一板一眼的 Python 不太一樣（Only one way to do it）。不過筆者建議大原則是盡量使用易讀易寫的 API 來完成工作，如果有細節需要處理再用其他的方法。例如一般開檔就使用 &lt;code&gt;File.open&lt;/code&gt; 或是 &lt;code&gt;Kernel.open&lt;/code&gt; 即可，需要存取 FD 則改用 &lt;code&gt;IO.open&lt;/code&gt;，若要手動關檔再考慮 &lt;code&gt;File.new&lt;/code&gt; 或 &lt;code&gt;IO.new&lt;/code&gt;。另外也不要特別使用 &lt;code&gt;Kernel.open&lt;/code&gt; 調用 &lt;code&gt;IO.popen&lt;/code&gt; 的奇怪語法（&lt;code&gt;|&lt;/code&gt;），這會降低程式碼的可讀性，不符合易讀易寫。像 &lt;code&gt;IO.popen('date')&lt;/code&gt; 就比 &lt;code&gt;Kernel.open('|date')&lt;/code&gt; 好懂多了。&lt;/p&gt;

&lt;p&gt;另一個原則是程式碼的一致性，如果團隊開檔案都使用 &lt;code&gt;File.open&lt;/code&gt;，那就盡量避免特立獨行使用 &lt;code&gt;Kernel.open&lt;/code&gt;，反之亦然。&lt;/p&gt;

</content>
  </entry>
</feed>
