<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不歸路</title>
  <subtitle>簡煒航的個人部落格</subtitle>
  <id>http://tonytonyjan.net</id>
  <link href="http://tonytonyjan.net"/>
  <link href="http://tonytonyjan.net/feed.xml" rel="self"/>
  <updated>2016-01-02T01:09:00+08:00</updated>
  <author>
    <name>大兜</name>
  </author>
  <entry>
    <title>2015 回顧</title>
    <link rel="alternate" href="http://tonytonyjan.net/2016/01/02/2015-review/"/>
    <id>http://tonytonyjan.net/2016/01/02/2015-review/</id>
    <published>2016-01-02T01:09:00+08:00</published>
    <updated>2016-01-02T22:01:49+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="" src="/images/2016-firework.jpg"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原來是 101 煙火啊，我還以為是洗瓶刷呢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;時間&lt;/th&gt;
      &lt;th&gt;工作&lt;/th&gt;
      &lt;th&gt;成就&lt;/th&gt;
      &lt;th&gt;日常&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;二月&lt;/td&gt;
      &lt;td&gt;待業&lt;/td&gt;
      &lt;td&gt;&lt;a href="/2015/02/23/feedback-to-confoo-2015"&gt;赴加拿大 confoo.ca 演講&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
 ...&lt;/tbody&gt;
&lt;/table&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="" src="/images/2016-firework.jpg" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原來是 101 煙火啊，我還以為是洗瓶刷呢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;時間&lt;/th&gt;
      &lt;th&gt;工作&lt;/th&gt;
      &lt;th&gt;成就&lt;/th&gt;
      &lt;th&gt;日常&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;二月&lt;/td&gt;
      &lt;td&gt;待業&lt;/td&gt;
      &lt;td&gt;&lt;a href="/2015/02/23/feedback-to-confoo-2015"&gt;赴加拿大 confoo.ca 演講&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;三月&lt;/td&gt;
      &lt;td&gt;進入索拉爾&lt;/td&gt;
      &lt;td&gt;上班一週就離職、&lt;a href="/rails-road"&gt;出了一本書&lt;/a&gt;（衝上博客來新書排行 No.2，天瓏 No.9）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;四月&lt;/td&gt;
      &lt;td&gt;進入 Ziltag&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;五月&lt;/td&gt;
      &lt;td&gt;Alpha Camp 客串講師&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;六月&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href="/2015/07/03/dream-of-traveling-abroad"&gt;第一次出國玩&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;七月&lt;/td&gt;
      &lt;td&gt;&lt;a href="/events/2015-07-ruby-on-rails-training"&gt;Rails 桃園班&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;課程在 1 週內 50 人額滿&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;八月&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;免役、從台科退學&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;九月&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href="https://youtu.be/0mphTtsekkI?t=3m13s"&gt;在 Ruby Conf Taiwan 演講&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;十月&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;湊合了第三對情侶，可以自封為媒人了&lt;/td&gt;
      &lt;td&gt;養貓了，脫離六年的獨居生活&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;十二月&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;a href="https://www.facebook.com/tonytonyjan/posts/10153377306582620"&gt;我的程式碼出現在 Ruby 2.3.0&lt;/a&gt;、&lt;a href="https://www.facebook.com/tonytonyjan/posts/10153405300657620"&gt;收到了 chef.io 的感謝函&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;湯圓大會、跨年晚會&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;另外值得慶祝的是：&lt;a href="https://chrome.google.com/webstore/detail/caafmojgjlbflohillejdmnghkpcjjpp"&gt;TJDict&lt;/a&gt; 突破 22k 使用人次了 :)&lt;/p&gt;

&lt;p&gt;2015 也是充滿各種刺激的一年，不過最值得慶祝的還是成功免役了，除了省下一些納稅人的錢，也幫家裡一個大忙，畢竟當一年兵就是把一年的年薪賠下去。且年初的時候還有收到澳洲、矽谷的 offer，但筆者那時因尚未服役或免役，所以就婉拒了，頓時心中頗有「中華民國誤我一生」的感覺，所幸但這件事情不會再發生了。&lt;/p&gt;

&lt;p&gt;新年嘛，難免許新希望，不過筆者自從去年領悟了及時行樂的智慧以後，就沒有什麼夢想了，感覺許下目標也沒什麼意義，當下活得不錯、無憂無疾就謝天謝地了，真要說的話大概是希望三十歲以前移民吧，但這是目標，不希望，兩者有些差異，目標是將會發生的事情，希望是即便沒發生也無妨。筆者想移民到非華人主宰的國家，然後如果可以一輩子不說中文，就一輩子不說。&lt;/p&gt;

&lt;p&gt;2016 正要開始，也不知道會發生什麼事情，畢竟回首過往，自己的人生似乎老走在鋼索上，只是相較往昔的自己，今日的心態已經平靜許多且可以輕鬆看待生死與成敗了，即便是從鋼索到跳火圈我想也是沒什麼大不了的。&lt;/p&gt;

&lt;p&gt;就這樣吧，新年快樂 :)&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>PTT 每天自動登入小程式</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/12/08/login-ptt-everyday-automatically/"/>
    <id>http://tonytonyjan.net/2015/12/08/login-ptt-everyday-automatically/</id>
    <published>2015-12-08T23:45:00+08:00</published>
    <updated>2015-12-09T13:17:12+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="" src="/images/ptt.png"&gt;&lt;/p&gt;

&lt;p&gt;最近大選近了，八卦版似乎將發文門檻調高到了 1000 次，帶風向的黨工少了，頓時清新了許多（不過仍然影響不到筆者）。其實養 PTT 帳號不容易，因為同一天只算登入一次，我們得每天記得登入一次 PTT，否則就平白損失了24 小時，如果沒有 PTT 成癮症，其實很容易忘記。&lt;/p&gt;

&lt;p&gt;而身為工程師如筆...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="" src="/images/ptt.png" /&gt;&lt;/p&gt;

&lt;p&gt;最近大選近了，八卦版似乎將發文門檻調高到了 1000 次，帶風向的黨工少了，頓時清新了許多（不過仍然影響不到筆者）。其實養 PTT 帳號不容易，因為同一天只算登入一次，我們得每天記得登入一次 PTT，否則就平白損失了24 小時，如果沒有 PTT 成癮症，其實很容易忘記。&lt;/p&gt;

&lt;p&gt;而身為工程師如筆者，為了遵守 DRY 原則，就應該寫個小程式去自動化這份工作才是。當然自己徒手寫程式建立 socket 與 PTT 做溝通是最直覺的想法，只不過 TCP 牽線容易，後續的 IO 處理則頗麻煩，為了模擬真實的操作，必須根據 socket 送來的字串判斷現在是要我們寫入帳號密碼還是按下回車。&lt;/p&gt;

&lt;p&gt;所幸這個問題在 1994 年就已經有人做出了專門的工具 &lt;code&gt;expect&lt;/code&gt;，用來將互動式的 IO 介面自動化。例如 &lt;code&gt;apt-get install&lt;/code&gt; 有時會被詢問一些是否覆蓋檔案或是安裝額外套件的問題，進而卡住，如果不用 &lt;code&gt;-y&lt;/code&gt; 之類的旗標，也可以透過 &lt;code&gt;expect&lt;/code&gt; 來實現。&lt;/p&gt;

&lt;p&gt;寫腳本之前先確認 &lt;code&gt;expect&lt;/code&gt; 的路徑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which expect
/usr/local/bin/expect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;expect&lt;/code&gt; 是基於 Tcl 的工具，意即 &lt;code&gt;expect&lt;/code&gt; 腳本就是 Tcl 腳本，以下是用 &lt;code&gt;expect&lt;/code&gt; 寫的 PTT 自動登入程式：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-tcl"&gt;#!/usr/local/bin/expect -f
set timeout 60
log_file -noappend $env(HOME)/log/ptt.log
spawn telnet ptt.cc
expect "new"
send "$env(PTT_ID)\r"
expect ":"
send "$env(PTT_PWD)\r"
expect {
  "您想刪除其他重複登入的連線嗎" {
    send "n\r"
    exp_continue
  }
  "請按任意鍵繼續" {
    send "\r"
    exp_continue
  }
  "批踢踢實業坊" {
    exit
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這裡要注意的是編碼問題，因為 PTT 是 BIG-5 編碼，直接在原始碼中放 UTF-8 的中文字串會導致誤判，筆者是先透過 &lt;code&gt;iconv -f UTF-8 -t BIG-5&lt;/code&gt; 處理原始碼。&lt;/p&gt;

&lt;p&gt;假設腳本命名為 ptt，使用方式為：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PTT_ID=PTT_帳號 PTT_PWD=PTT_密碼 ptt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至於每天都執行一次的任務，就交給 &lt;code&gt;crontab&lt;/code&gt; 即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=/path/to/ptt/bin
6 6 * * * LC_ALL=zh_TW.Big5 PTT_ID=帳號 PTT_PWD=密碼 ptt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大功告成！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby SSE Server 動手做</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/11/05/concurrent-ruby/"/>
    <id>http://tonytonyjan.net/2015/11/05/concurrent-ruby/</id>
    <published>2015-11-05T01:10:00+08:00</published>
    <updated>2015-11-05T22:50:39+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">
&lt;p&gt;&lt;strong&gt;本篇文章同時也發表於 &lt;a href="http://weekly.codetengu.com/"&gt;CodeTengu&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/push_server.jpg"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;照片是日本硬體製造商 Speedlink 在東京舉辦的 server 投擲大賽，誰能把 server 推得最遠，可以得到最高的分數，圖片中的機器值 50 萬日幣，這也是名符其實的 push server，&lt;a href="https://www.youtube.com/watch?v=A_j_iBH6wTI"&gt;影片在此&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近要蓋個 &lt;a href="http://www.wikiwand.com/en/Server-sent_events"&gt;SSE&lt;/a&gt;&lt;/p&gt;</summary>
    <content type="html">
&lt;p&gt;&lt;strong&gt;本篇文章同時也發表於 &lt;a href="http://weekly.codetengu.com/"&gt;CodeTengu&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/push_server.jpg" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;照片是日本硬體製造商 Speedlink 在東京舉辦的 server 投擲大賽，誰能把 server 推得最遠，可以得到最高的分數，圖片中的機器值 50 萬日幣，這也是名符其實的 push server，&lt;a href="https://www.youtube.com/watch?v=A_j_iBH6wTI"&gt;影片在此&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近要蓋個 &lt;a href="http://www.wikiwand.com/en/Server-sent_events"&gt;SSE&lt;/a&gt; 服務，筆者因貪一時方便就暫時使用 &lt;a href="https://github.com/puma/puma"&gt;puma&lt;/a&gt; 在 Rails 上實現，但畢竟用執行緒解決長請求是很不妙的行為，這幾天就用 Ruby 開始徒手寫了 I/O multiplexing 伺服器，有種回到學生時代的感覺，只是 Ruby 只有 &lt;code&gt;select()&lt;/code&gt;，少了 &lt;code&gt;epoll()&lt;/code&gt;、&lt;code&gt;kqueue()&lt;/code&gt; 很不方便，好在 &lt;a href="https://github.com/eventmachine/eventmachine"&gt;eventmachine&lt;/a&gt; 背後使用的是 &lt;a href="http://software.schmorp.de/pkg/libev.html"&gt;libev&lt;/a&gt; 和 &lt;a href="https://github.com/libevent/libevent"&gt;libevent&lt;/a&gt;，有用到上述兩個系統調用，但筆者其實是最希望使用 &lt;a href="https://github.com/libuv/libuv"&gt;libuv&lt;/a&gt; 呢（一副要逼人貢獻的節奏啊），另外一個方案是用 &lt;a href="https://github.com/celluloid/celluloid"&gt;celluloid&lt;/a&gt; 替代 &lt;a href="https://github.com/eventmachine/eventmachine"&gt;eventmachine&lt;/a&gt;，但前者在 I/O 的處理上&lt;a href="https://github.com/celluloid/celluloid-io/blob/5e96845e68fdcd406717e3ab543b0099168a1c15/lib/celluloid/io.rb"&gt;仍然使用 &lt;code&gt;Kernel.select()&lt;/code&gt;&lt;/a&gt;，筆者也就作罷。&lt;/p&gt;

&lt;h1 id="rails-"&gt;Rails 即時串流&lt;/h1&gt;

&lt;p&gt;雖然以 Rails 時下的 HTTP server 方案，要做串流服務有點吃力，但要做也是可行的，串流功能在 Rails 4 後才開始支援，controller 需要 mix &lt;code&gt;ActionController::Live&lt;/code&gt; 才可以使用 &lt;code&gt;response.stream&lt;/code&gt;，建議可以參考 tenderlove 在 2012 寫的 &lt;a href="http://tenderlovemaking.com/2012/07/30/is-it-live.html"&gt;Is it live?&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class MyController &amp;lt; ActionController::Base
  include ActionController::Live

  def stream
    response.headers['Content-Type'] = 'text/event-stream'
    100.times {
      response.stream.write "hello world\n"
      sleep 1
    }
  ensure
    response.stream.close
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述程式碼不至於難以理解，頂多注意要記得關掉 stream，否則打開的 socket 會一直開著直到海枯石爛，導致最系統上的檔案描述符被一堆死掉的 socket 佔用。&lt;/p&gt;

&lt;p&gt;大家要更關注的應該是 HTML5 支援的 SSE 功能要怎麼在 Rails 上實現，當然我們可直接徒手寫：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class MyController &amp;lt; ActionController::Base
  include ActionController::Live

  def index
    response.headers['Content-Type'] = 'text/event-stream'
    3.times {
      response.stream.write "event: time\ndata: #{Time.now}\n\n"
    }
  ensure
    sse.close
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;data&lt;/code&gt; 部分是任意的字串，不過大部分的案例我們會使用 JSON，好讓 client 端可以更輕易取得資料，但這樣新版本的寫法會用到許多 &lt;code&gt;Hash#to_json&lt;/code&gt; 或 &lt;code&gt;Array#to_json&lt;/code&gt;，且徒手送出符合 SSE 規格的字串也很不方便，好在 Rails 也有 &lt;code&gt;ActionController::Live::SSE&lt;/code&gt; 可以用：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class MyController &amp;lt; ActionController::Base
  include ActionController::Live

  def index
    response.headers['Content-Type'] = 'text/event-stream'
    sse = SSE.new(response.stream, retry: 300, event: "event-name")
    sse.write({ name: 'John'})
    sse.write({ name: 'John'}, id: 10)
    sse.write({ name: 'John'}, id: 10, event: "other-event")
    sse.write({ name: 'John'}, id: 10, event: "other-event", retry: 500)
  ensure
    sse.close
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ActionController::Live::SSE&lt;/code&gt; 跟 tenderlove 在 2012 寫的版本大同小異，即便是在 Rails 4 上，也是一段不到 40 行的類別，目的是將 &lt;code&gt;#write&lt;/code&gt; 方法包裝，讓本來只能寫入字串的 &lt;code&gt;#write&lt;/code&gt;，變得可以傳入物件（大多情況下是 Hash 或是 Array 物件），片段程式碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;def write(object, options = {})
  case object
  when String
    perform_write(object, options)
  else
    perform_write(ActiveSupport::JSON.encode(object), options)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="rails--http-"&gt;別用 Rails 做 HTTP 推送服務&lt;/h2&gt;

&lt;p&gt;從以前工程師就在苦思如何在有限的運算單位與記憶體之下服務更多的訪客，Rails 的並行性目前已有許多方案，做法不外乎是用執行緒（puma）、行程（unicorn）或者兩者並行（rainbows、puma clustered mode），無論何者，每個連線都會佔用至少一個行程或是執行緒，直到 action 方法執行結束才會釋放資源。&lt;/p&gt;

&lt;p&gt;這種架構適合運算密集的服務，通常一份 HTML 可以在 300ms 內傳輸完畢，I/O 佔用的時間很短，行程或執行緒可以很快被釋放；但如果是 I/O 密集的服務（例如串流服務），由於 I/O 佔用時間長，所以我們通常不會一些像是影片的大檔案放在 Rails 的 action 中去傳輸，而是丟到 public 目錄下或是 S3。&lt;/p&gt;

&lt;p&gt;舉例如果有個影片需要 1 分鐘的下載時間，我們交給 Rails 去處理，且 puma 設定支援 32 個執行緒，那麼同一分鐘內只能有最多 32 人可以看影片，如果你要蓋一個 YouTube 或 RedTube，同一時間只能服務最多 32 人，會很不方便。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;把執行緒限制調高到十萬？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;調高到十萬並不是什麼好事，想像一下，一台機器有上萬個執行緒在跑，但是只有 4 顆處理器是個怎樣的情形，光是上下文交換就可以耗盡資源了，何況好不容易交換到某個執行緒，結果 I/O 太忙，連一個位元組也沒傳到就又被交換走了。&lt;/p&gt;

&lt;p&gt;所以即便在 Rails 做 SSE 是如此容易，筆者也不會建議用 Rails 做 SSE，理由是支援 Rails 的 HTTP 伺服器，無論是 unicorn 或 puma 等皆然，它們每服務一個連線會佔用一個行程或是執行緒造成阻塞，此架構下不適合實作提供長久連線的服務（例如 push server 網路遊戲、聊天室等）。&lt;/p&gt;

&lt;h1 id="io-multiplexing-"&gt;I/O Multiplexing 動手做&lt;/h1&gt;

&lt;p&gt;Ruby 內建相關的系統調用只有 &lt;code&gt;select()&lt;/code&gt;，沒有 &lt;code&gt;epoll()&lt;/code&gt;、沒有 &lt;code&gt;kqueue&lt;/code&gt;，在阻塞方面也只有提供 &lt;code&gt;IO#read_nonblock&lt;/code&gt; 和 &lt;code&gt;IO#write_nonblock&lt;/code&gt;，沒有支援 AIO，在這樣的資源下，選用非同步阻塞的策略也是很合理的，筆者先後用原生 Ruby 做了第一個版本，再用 eventmachine 做了另外一個，程式碼如下：&lt;/p&gt;

&lt;h2 id="kernelselect"&gt;Kernel.select()&lt;/h2&gt;

&lt;p&gt;Ruby 有內建 &lt;code&gt;select()&lt;/code&gt; 系統調用可以使用，但 &lt;code&gt;select()&lt;/code&gt; 最大的弱點是受到 &lt;code&gt;FD_SETSIZE&lt;/code&gt; 的限制，除非重新編譯內核，否則在許多 Linux 發行下預設是 1024，扣掉 server socket，只能服務 1023 個訪客，所以這段程式碼可用於學習，不建議用在產品中：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;require 'socket'

SERVER_SOCKET = TCPServer.new 'localhost', 3310
SOCKETS = [SERVER_SOCKET]

Thread.new do
  loop do
    clients = SOCKETS - [SERVER_SOCKET]
    clients.each do |socket|
      socket.send "event: time\ndata: #{Time.now}\n\n", 0
    end
    sleep 1
  end
end

# I/O loop
loop do
  # 這行是阻塞的，直到有任何一個檔案描述符狀態變成可讀或可寫，內核會主動通知
  ready_to_read, ready_to_write, in_error = select(SOCKETS, [], [])
  ready_to_read.each do |socket|
    case socket
    when SERVER_SOCKET
      client_socket, client_addrinfo = SERVER_SOCKET.accept
      SOCKETS &amp;lt;&amp;lt; client_socket
      puts "connect: #{client_socket}"
    else # 若非 server 即 client socket
      begin
        socket.recv(1024)
        socket.send "HTTP/1.1 200 OK
Server: Ziltag Push Server
Content-Type: text/event-stream
Connection: keep-alive
Access-Control-Allow-Origin: *\n\n", 0
      rescue
        $stderr.puts $!, $@
        SOCKETS.delete(socket)
        puts "disconnect: #{socket}"
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你願意重編內核調高 &lt;code&gt;FD_SET_SIZE&lt;/code&gt;，這個做法是滿足 C10K 的。&lt;/p&gt;

&lt;h1 id="eventmachine"&gt;eventmachine&lt;/h1&gt;

&lt;p&gt;可惜 &lt;code&gt;select()&lt;/code&gt; 有諸多問題讓人們漸漸放棄使用，好在 eventmachine 使用 libevent，會根據作業系統去支援相對的系統調用，在 Linux 選用 &lt;code&gt;epoll()&lt;/code&gt;，在 FreeBSD 選用 &lt;code&gt;kqueue()&lt;/code&gt;，且提供了抽象的介面讓使用者可以輕易實作出 I/O 事件驅動的程式：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;require 'eventmachine'

class PushServer &amp;lt; EM::Connection
  @@clients = []

  def self.clients
    @@clients
  end

  def broadcast msg, slugs
    @@clients.each do |client|
      client.send_data msg
    end
  end

  def post_init
    @@clients &amp;lt;&amp;lt; self
    puts "#{self} connected"
  end

  def receive_data data
    send_data "HTTP/1.1 200 OK
Server: Ziltag Push Server
Content-Type: text/event-stream
Connection: keep-alive
Access-Control-Allow-Origin: *\n\n"
  end

  def unbind
    @@clients.delete(self)
    puts "#{self} disconnected"
  end
end

EventMachine.run do
  EventMachine.add_periodic_timer(1) do
    PushServer.clients.each do |client|
      client.send_data "event: time\ndata: #{Time.now}\n\n"
    end
  end
  EventMachine.start_server '0.0.0.0', 3310, PushServer
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eventmachine 在連線產生時，會去監聽該 socket 描述符，收到資料時會觸發 &lt;code&gt;#receive_data&lt;/code&gt;，比起剛剛的 &lt;code&gt;select()&lt;/code&gt; 實作，使用 eventmachine 會更容易維護，且可以輕易在 I/O 策略上做切換（例如在 &lt;code&gt;EventMachine.run&lt;/code&gt; 之前先執行 &lt;code&gt;EventMachine.epoll&lt;/code&gt;），很方便。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;為何不用 celluloid？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;celluloid 是為了解決 concurrent 問題而存在的，比起 eventmachine，他的應用層面更廣泛，因為在真實世界中遇到的問題不會只有 I/O 要處理，有些計算密集的程式用 thread 也許更有效率，所以 celluloid 的作者決定同時用了執行緒和 I/O multiplexing 兩種技巧去解決所有並行的問題，而 eventmachine 只是 celluloid 的其中一個擴展而已（&lt;a href="https://github.com/celluloid/celluloid-io"&gt;celluloid-io&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;但筆者只是單純寫個 SSE 服務，用 eventmachine 就綽綽有餘了，即便 eventmachine 只用到一顆處理器，但多開幾個伺服器然後反向代理也是可以做到橫向擴展。&lt;/p&gt;

&lt;h1 id="section"&gt;結論&lt;/h1&gt;

&lt;p&gt;Rails 不是萬靈丹，即便支援了串流功能，仍不適合做 I/O 密集的應用，不過 Rails 5 的 Action Cable 是可以期待一下，因為這東西使用的是 eventmachine 和執行緒，很適合用來維持大量的連線，不過這是為了 websocket 而寫，如果是要做 comet 的應用（長請求），最好另尋方法，使用 Rails 恐怕是繞遠路，以 Ruby 的方案來看，著名的專案就屬 eventmachine 與 celluloid。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;或者叛逃到 node 或 go 也行啦&lt;/del&gt;&lt;/p&gt;

&lt;h1 id="section-1"&gt;本文出現的連結&lt;/h1&gt;

&lt;h2 id="section-2"&gt;好文&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://www.wikiwand.com/en/Server-sent_events"&gt;SSE&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://www.slideshare.net/KyleDrake/hybrid-concurrency-patterns"&gt;Hybrid Concurrency Patterns&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/cn/linux/l-async"&gt;使用异步 I/O 大大提高应用程序的性能&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://tenderlovemaking.com/2012/07/30/is-it-live.html"&gt;Is it live?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://www.html5rocks.com/en/tutorials/eventsource/basics"&gt;Stream Updates with Server-Sent Events&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="section-3"&gt;開原專案&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/puma/puma"&gt;puma&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://www.kegel.com/c10k.html"&gt;The C10K Problem&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://software.schmorp.de/pkg/libev.html"&gt;libev&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/eventmachine/eventmachine"&gt;eventmachine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/celluloid/celluloid"&gt;celluloid&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/libevent/libevent"&gt;libevent&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/libuv/libuv"&gt;libuv&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/celluloid/celluloid-io"&gt;celluloid-io&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/rails/actioncable"&gt;actioncable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ruby Conference Taiwan 2015</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/08/06/ruby-conference-taiwan-2015/"/>
    <id>http://tonytonyjan.net/2015/08/06/ruby-conference-taiwan-2015/</id>
    <published>2015-08-06T03:34:00+08:00</published>
    <updated>2015-08-18T18:03:11+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;a href="http://2015.rubyconf.tw/"&gt;&lt;img src="/images/ruby-conf-tw-2015.png" width="100%"&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://2015.rubyconf.tw/"&gt;大會官網&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一年一度的 Ruby Conference 又來啦，今年的明星陣容除了與去年一樣有邀請到 Ruby 之父松本行弘（Matz），Rails 的核心開發者 Aaron Patterson（tenderlove），以及一位來自日本的 CRuby 核心開發者芝田浩（hsbt）。&lt;/p&gt;

&lt;p&gt;大會...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;a href="http://2015.rubyconf.tw/"&gt;&lt;img src="/images/ruby-conf-tw-2015.png" width="100%" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://2015.rubyconf.tw/"&gt;大會官網&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一年一度的 Ruby Conference 又來啦，今年的明星陣容除了與去年一樣有邀請到 Ruby 之父松本行弘（Matz），Rails 的核心開發者 Aaron Patterson（tenderlove），以及一位來自日本的 CRuby 核心開發者芝田浩（hsbt）。&lt;/p&gt;

&lt;p&gt;大會議程主題種類多元，從 Rails 前後端網頁應用到 Ruby 與 C library 的串接都有。如果你對於 Ruby 的效能問題感興趣，可以參考 tka 的「如何用 golang 幫 ruby 專案加速」以及林鈺翔的「Need for Speed: Boost ruby with FFI」，分別應用了不同的程式語言替 Ruby 加速（雖然筆者仍喜歡直接調用 Ruby 的 C API 去寫 C 擴展）。&lt;/p&gt;

&lt;p&gt;此外筆者小投一篇近來對 Rails 前端套件的管理心得，僥倖錄取了，如果你對 Rails 上的前端套件管理有興趣，除了筆者的講題「還給前端工程師一個天空」之外，也建議也可以參考講者何澤清的「gem 'webpack-rails'」，分別使用的技術是 gulp 與 webpack。&lt;/p&gt;

&lt;p&gt;而以國際化為重的 Ruby Conf Taiwan 今年議程也有 13 個國家的開發者投稿議程，將會為聽眾們帶來許多精彩的演說。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rails 購物車設計</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/08/05/design-cart-system-in-rails/"/>
    <id>http://tonytonyjan.net/2015/08/05/design-cart-system-in-rails/</id>
    <published>2015-08-05T21:14:00+08:00</published>
    <updated>2015-10-08T22:24:11+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="" src="/images/cart.png"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;封面圖片為 Minecraft 遊戲的截圖，軌道上的貨車（cart on rails），筆者也算是從 alpha 版就開始玩的老玩家呢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;隨著電子商務的崛起，網站上的購物車系統已經成了普遍的功能，這幾年 Rails 在台灣也快速竄紅，且由 Dave Thomas 與 David Heinemeier...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="" src="/images/cart.png" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;封面圖片為 Minecraft 遊戲的截圖，軌道上的貨車（cart on rails），筆者也算是從 alpha 版就開始玩的老玩家呢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;隨著電子商務的崛起，網站上的購物車系統已經成了普遍的功能，這幾年 Rails 在台灣也快速竄紅，且由 Dave Thomas 與 David Heinemeier Hansson 所著的「&lt;a href="https://pragprog.com/book/rails4/agile-web-development-with-rails-4"&gt;Agile Web Development with Rails 4&lt;/a&gt;」一書中也有購物車範例。即便如此，仍然有許多開發者對於設計真正可用的購物車平台感到挫折。&lt;/p&gt;

&lt;p&gt;其中一個理由是書中對於購物車、訂單、發票等規劃並沒有詳細的介紹，其二則是台灣的第三方支付並沒有任何一家廠商提供足夠友善的 API 供開發者使用。&lt;/p&gt;

&lt;h1 id="section"&gt;購物車系統起手式&lt;/h1&gt;

&lt;p&gt;該如何設計一個購物車系統呢？在思考這個問題前不妨先想想從挑選商品到放入購物車，到最後結帳的過程中，可以切出哪些 entity 以方便規劃資料庫，我們隨即可以直覺的想到有「商品」與「購物車」，而以下就是一個初步的 &lt;a href="https://www.wikiwand.com/en/Entity%E2%80%93relationship_model"&gt;Entity-Relation diagram&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/erd/2.png" /&gt;&lt;/p&gt;

&lt;h2 id="section-1"&gt;保留金額資訊&lt;/h2&gt;

&lt;p&gt;沒道理筆者拿了一罐牛奶，你就只能挑豆漿，所以研判一個購物車可以有多個產品，且一個產品放進多個購物車，而這樣的設計圖乍看完美卻有個問題：試想當一個訪客挑選了一樣產品，並且放入購物車，這時如果該產品的價錢被後台管理員異動，那麼在訪客結帳之前購物車中的商品價錢也需要異動嗎？&lt;/p&gt;

&lt;p&gt;如果這是被允許的，那麼筆者可以在訪客結帳的前一秒，將價錢偷改為幾百萬（之後幾年就是官司人生），於是我們需要新的設計避免這樣的悲劇：&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/erd/3.png" /&gt;&lt;/p&gt;

&lt;p&gt;這樣就好了許多，LineItem（在其他 Rails 的專案中，有的人會將 LineItem 命名為 CartItem）作為關聯 Product 與 Cart 的角色之外，還需額外儲存數量與金額資訊，這個金額必須是該產品加入購物車當下的數字，如此結帳時才不會有爭議價錢異動的爭議。&lt;/p&gt;

&lt;h2 id="section-2"&gt;「訂單」與「購物車」的差異？&lt;/h2&gt;

&lt;p&gt;「訂單」與「購物車」在電子商務系統中扮演的角色相似卻也有些差異，相似是兩者都同樣會記錄訪客加入購物車的商品的當前價錢與數量，差異則是「購物車」可編輯商品資訊（例如數量或新增商品），但「訂單」除了付款之外，不可再異動商品資訊，且「訂單」會擁有更多如地址、姓名、統編等一類的通訊資料。&lt;/p&gt;

&lt;p&gt;加上「訂單」後的設計圖：&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/erd/5.png" /&gt;&lt;/p&gt;

&lt;h2 id="section-3"&gt;付款紀錄&lt;/h2&gt;

&lt;p&gt;「訂單」不能異動，唯一可以執行的動作就是「付款」。可是付款未必每次都會成功，且無論成功與否都應該留個記錄，記錄除了方便管理員查詢、找出問題之外，也能提供給使用者供參考與留存。&lt;/p&gt;

&lt;p&gt;「交易紀錄」不需通訊資料，只需要記錄成功與否、交易編號即可，以下是新的設計圖：&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/erd/7.png" /&gt;&lt;/p&gt;

&lt;p&gt;你大概會注意到 Trade 有個 &lt;code&gt;params:text&lt;/code&gt; 屬性，這是用來存放第三方支付服務所回傳的資料，可能是 JSON 或是 XML 格式，搭配 ActiveRecord 中的 &lt;a href="http://api.rubyonrails.org/classes/ActiveRecord/AttributeMethods/Serialization/ClassMethods.html#method-i-serialize"&gt;&lt;code&gt;#serialize&lt;/code&gt;&lt;/a&gt;，可以輕易存取這個欄位以供日後的查閱由服務所回傳的原始交易資料。&lt;/p&gt;

&lt;h1 id="section-4"&gt;其他人怎麼做？&lt;/h1&gt;

&lt;p&gt;像購物車系統如此常見的功能，想必也有許多開源項目可以使用，其中最有名的三個專案分別是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/drhenner/ror_ecommerce"&gt;ror_ecommerce&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://spreecommerce.com/"&gt;Spree&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/piggybak/piggybak"&gt;Piggybak&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="rorecommerce"&gt;ror_ecommerce&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/ror-ecommerce.png" /&gt;&lt;/p&gt;

&lt;p&gt;是由 &lt;a href="https://github.com/drhenner"&gt;David Henner&lt;/a&gt; 在設計一個電子商務系統時，順手開源的項目，並且寫了&lt;a href="http://www.ror-e.com/"&gt;一個網站&lt;/a&gt;解釋他的設計哲學，即便這個項目是三個之中更新最慢的，但對於想學習如何徒手製作電子商務網站的人來說，筆者認為這是最值得參考的學習文件。&lt;/p&gt;

&lt;p&gt;ror_ecommerce 的資料庫設計與本篇文章的示意圖、以及「Agile Web Development with Rails 4」書中的範例相同。&lt;/p&gt;

&lt;h2 id="spree"&gt;Spree&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/spree.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Spree 是 Rails 開源電子商務圈最著名的項目，是由許多資深工程師組成的核心團隊所開發，其中不乏 Apache 軟體協會的成員與公司的 CTO、CEO，品質保證，加上完整的 API、文件以及活絡的社群，此外與 ActiveMerchant 相容性高，對於單純只是想要快速架設電子商務網站的人來說，Spree 堪稱首選。&lt;/p&gt;

&lt;p&gt;資料結構方面，有別於前述的架構，Spree 並沒有 Cart entity，而是在 Order 之中新增一個 &lt;code&gt;state&lt;/code&gt; 屬性將「訂單」偽裝成「購物車」的行為，導致 Order 的行為邏輯比 Cart 複雜，但是可以實現的功能更多。&lt;/p&gt;

&lt;h2 id="piggybak"&gt;Piggybak&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/piggybak.png" /&gt;&lt;/p&gt;

&lt;p&gt;算是 Rails 開源電子商務的後起之秀，沒有 Spree 那樣完備，但其模組化的彈性使得許多開發者也開始投像 Piggybak 的懷抱，這層關係有點像 Paperclip 與 CarrierWave 之間一樣，後者也是以模組化著稱。&lt;/p&gt;

&lt;p&gt;你可以在 Rails 中任何一個 ActiveRecord model 中掛上 &lt;code&gt;acts_as_sellable&lt;/code&gt; 使其成為可以買賣的商品，相當簡便，如果你想要的是在既有的網站上加上購物功能，而非重新打造一個購物網站，也許這是讓你選擇 Piggybak 而非 Spree 的誘因。&lt;/p&gt;

&lt;h1 id="section-5"&gt;結語嗎&lt;/h1&gt;

&lt;p&gt;購物車系統沒有什麼「一定得這樣」的設計，不管是什麼架構的購物車，可以結帳的就是好的購物車。如果對於設計購物車仍有疑惑，也建議不妨多看看他人的開源項目怎麼設計，其實許多書中找不到的答案，都放在程式碼裡面，而優良的程式碼更是可以閱讀的。&lt;/p&gt;

&lt;p&gt;筆者也有一份串接歐付寶的範例網站就放在 &lt;a href="https://github.com/tonytonyjan/brainana_shop"&gt;Github&lt;/a&gt; 上，有興趣的讀者可供參考，當然，也歡迎送 patch =)&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>[台北] 艾斯糖 S Don</title>
    <link rel="alternate" href="http://tonytonyjan.net/2015/07/14/s-don/"/>
    <id>http://tonytonyjan.net/2015/07/14/s-don/</id>
    <published>2015-07-14T17:19:00+08:00</published>
    <updated>2015-07-15T08:43:31+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="" src="/images/s-don.png"&gt;&lt;/p&gt;

&lt;p&gt;店名：艾斯糖（S Don）&lt;br&gt;
地址：台北市大安區新生南路一段 97 巷 13 號&lt;br&gt;
網址：&lt;a href="https://www.facebook.com/pages/%E8%89%BE%E6%96%AF%E7%B3%96-S-Don/678897485514918"&gt;https://www.facebook.com/pages/艾斯糖-S-Don/678897485514918&lt;/a&gt;&lt;br&gt;
營業時間：周一 - 周四 10:15 - 20:00；周五 - 周六 10:15 - 21...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="" src="/images/s-don.png" /&gt;&lt;/p&gt;

&lt;p&gt;店名：艾斯糖（S Don）&lt;br /&gt;
地址：台北市大安區新生南路一段 97 巷 13 號&lt;br /&gt;
網址：&lt;a href="https://www.facebook.com/pages/%E8%89%BE%E6%96%AF%E7%B3%96-S-Don/678897485514918"&gt;https://www.facebook.com/pages/艾斯糖-S-Don/678897485514918&lt;/a&gt;&lt;br /&gt;
營業時間：周一 - 周四 10:15 - 20:00；周五 - 周六 10:15 - 21：00；周日 10:15 - 18：00&lt;br /&gt;
SOHO 評價：★★★★☆&lt;/p&gt;

&lt;h2 id="section"&gt;簡介&lt;/h2&gt;

&lt;p&gt;自從筆者把其中一間房間佈置成工作室之後，就已經鮮少在網誌上介紹適合工作的咖啡廳了。然而最近鄰居非常勤勞地在施工裝潢，且早上八點就開始鑽牆，弄的筆者除了被吵醒之外，也無法專心在家工作。只好外出尋覓避難所，所幸找到了這家咖啡廳「艾斯糖」。&lt;/p&gt;

&lt;h2 id="wifi"&gt;WIFI、電源、安靜、不限時&lt;/h2&gt;

&lt;p&gt;&lt;img src="/images/s-don-seats.jpg" width="100%" /&gt;&lt;/p&gt;

&lt;p&gt;這家店就這麼低調的藏在捷運忠孝新生站附近的巷子裡，遠離人車的吵雜，比起鬧區的店要來的安靜許多，且店內除了提供免費的 WIFI 之外，每個座位附近都至少會鄰近一組插座，這讓習慣抱著筆電四處跑的網路工作者與 SOHO 族來說相當的方便，而桌子不至於太小，也適合與隊友們在此做些小討論或開會，除了上述的功能之外，以一個咖啡廳而言也適合平日與好友一起來下午茶。&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-books.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;即便沒有自備讀物，書架上也有許多種類的閒書供取閱，其實不妨偶爾挑個悠閒的午後，在這裡隨機抽一本有緣的書來閱讀，配一杯咖啡，也可以愜意的在這裡度過半天。&lt;/p&gt;

&lt;h2 id="section-1"&gt;貓奴的選擇&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-cat.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;如果你也愛貓，也許可以來和副店長「艾斯」做個朋友，記得筆者與他的第一次的邂逅時，他正慵懶的睡在書架的格子裡。雖然艾斯對於第一次見面的陌生人也許不太理會，但基本上也不太怕生。這天筆者整個下午在店裡寫程式，寫到一半艾斯就跳到腿上，本來應該很溫馨的，可惜寫程式需要非常專注的腦力，所以筆者是被嚇到的XD&lt;/p&gt;

&lt;p&gt;這裡總共有兩隻貓，經店員解釋，在假日才有機會遇到另一隻野生的喵星人，好奇的朋友不妨可以挑假日來拜訪。&lt;/p&gt;

&lt;h2 id="section-2"&gt;不定期的小活動&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-dolls.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;這家店的空間利用也頗多元，時有不定期的展演活動或手工藝教學，種類應有盡有，如上圖即是某次「週六小學堂」的主題：襪子娃娃。此外店裡也提供投影設備，經過預約即可使用，所以除了上述一般手工藝或是靜態的展覽之外，在此辦小講座、讀書會抑或電影欣賞也不會是問題。而筆者也考慮也許下一場 Taipei.rb 可以辦在這裡。&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-represent.png" /&gt;&lt;/p&gt;

&lt;h2 id="section-3"&gt;食物&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="/images/s-don-food.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;價位方面，低消是一杯飲料，每個餐點無論飲品或食物大多落在 100 至 200 元之間。&lt;/p&gt;

&lt;p&gt;食物方面，無奈筆者舌頭不太敏感，向來對食物不敢妄下點評，但經過筆者的強者朋友表示這裡的拿鐵非常好喝且順口，對咖啡有研究的人說不定可以來此驗證看看。&lt;/p&gt;

&lt;p&gt;值得一提的是這家店的菜單是「活」的，有季節限定的限量的手工點心，看起來也有在推陳出新，所以無論你是常客還是過客，每次來訪並不至於失去新鮮感。&lt;/p&gt;

&lt;h2 id="section-4"&gt;總評&lt;/h2&gt;

&lt;p&gt;來就對了XD&lt;/p&gt;
</content>
  </entry>
</feed>
