<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不歸路</title>
  <subtitle>簡煒航的個人部落格</subtitle>
  <id>https://tonytonyjan.net</id>
  <link href="https://tonytonyjan.net"/>
  <link href="https://tonytonyjan.net/feed.xml" rel="self"/>
  <updated>2016-12-29T16:58:00+08:00</updated>
  <author>
    <name>大兜</name>
  </author>
  <entry>
    <title>我的貓 - 黏黏和歲歲</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/12/29/my-cat/"/>
    <id>https://tonytonyjan.net/2016/12/29/my-cat/</id>
    <published>2016-12-29T16:58:00+08:00</published>
    <updated>2018-04-21T10:55:55+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;似乎從來沒有介紹過家裡的貓，索性來出賣幾張照片吧！&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161110.jpg" alt=""&gt;&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;似乎從來沒有介紹過家裡的貓，索性來出賣幾張照片吧！&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161110.jpg" alt="" /&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src="/images/cats/20160911-2.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20160911.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161203.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161027.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161004.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161007.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;筆者自 2015 十月開始認養第一隻貓咪，2016 六月認養第二隻，由於從小到大沒有養寵物的經驗，不知從和開始，前三個月不是四處問人就是不斷上網找資料。好在中途之家的姊姊很熱心，總是親切地回答我的問題。&lt;/p&gt;

&lt;h2 id="飲食"&gt;飲食&lt;/h2&gt;

&lt;p&gt;因為知道了近幾年台灣開始吹起了濕食風，遂一開始就沒有打算買乾飼料，就先從三餐吃罐頭開始。試過了顛峰、鈕翠寶、Goody 等等。最後是顛峰的口性最好，雖然顛峰不便宜，當時筆者才養一隻貓，負擔尚可，但第二隻住進來後有些吃緊，筆者也開始找其他濕食管道。&lt;/p&gt;

&lt;p&gt;後來知道台灣有幾家廠商有在做寵物生食，像是汪喵、巴夫等，索性買了一條回家嘗試，不料家裡主子愛吃到把整個碗舔地乾乾淨淨，筆者心喜之下果斷買了幾箱。&lt;/p&gt;

&lt;p&gt;就這樣，她們之後都吃生肉，回歸原始的飲食，而不是加工過的罐頭。&lt;/p&gt;

&lt;h2 id="健康"&gt;健康&lt;/h2&gt;

&lt;p&gt;只有姊姊黏黏看過病，剛來筆者家裡第一天就發燒了。初養前十天就要照顧病貓，這對第一次養寵物的人來說實在是一件很困難的事，但也因此筆者在剛養貓的第一個禮拜就學會了投藥的技能，記得第一次投藥前看了十幾部 YouTube 教學影片，就怕自己做錯一步，害到了黏黏。&lt;/p&gt;

&lt;h2 id="娛樂"&gt;娛樂&lt;/h2&gt;

&lt;p&gt;本來以為只要是逗貓棒就可以吸引貓咪，但好像還是得看個性才行。歲歲會為了彩帶棒瘋狂，但黏黏對貓草娃娃比較感興趣，這讓筆者每次選購玩具都會考慮買到兩種以上。&lt;/p&gt;

&lt;p&gt;根據觀察，貓似乎無法分辨棉被和床中間有一層空間，或是無法理解筆者蓋上被子是什麼概念，每次筆者埋進一隻手在棉被裡搓出一點聲音，她們就會開始隔著棉被狩獵筆者的手，好氣又好笑。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;養寵物真的事很棒的一件事，尤其是對獨居太久的人，加上如果工作性質又屬於 SOHO 的話，長久下來真的會生病，有個寵物陪在身邊，生活也比較不會憂鬱。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby#open 知多少？</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/06/15/comparison-of-ruby-open/"/>
    <id>https://tonytonyjan.net/2016/06/15/comparison-of-ruby-open/</id>
    <published>2016-06-15T00:12:00+08:00</published>
    <updated>2018-04-21T10:55:55+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文同步發表於 &lt;a href="https://blog.alphacamp.co/2016/06/30/ruby-open/"&gt;alphacamp&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/io.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;先來個快問快答吧：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果現在要你使用 Ruby 去開檔，你會想到怎麼做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直覺是使用 &lt;code&gt;File.open&lt;/code&gt;，但想想 &lt;code&gt;File.new&lt;/code&gt; 似乎也可行，然後又發現不使用 &lt;code&gt;File&lt;/code&gt; 類別，直接用 &lt;code&gt;open&lt;/code&gt; 也能做到一樣的事。去查了 Ruby 文件結果...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;strong&gt;本文同步發表於 &lt;a href="https://blog.alphacamp.co/2016/06/30/ruby-open/"&gt;alphacamp&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/io.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;先來個快問快答吧：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果現在要你使用 Ruby 去開檔，你會想到怎麼做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直覺是使用 &lt;code&gt;File.open&lt;/code&gt;，但想想 &lt;code&gt;File.new&lt;/code&gt; 似乎也可行，然後又發現不使用 &lt;code&gt;File&lt;/code&gt; 類別，直接用 &lt;code&gt;open&lt;/code&gt; 也能做到一樣的事。去查了 Ruby 文件結果發現 &lt;code&gt;IO.open&lt;/code&gt; 和 &lt;code&gt;IO.new&lt;/code&gt; 也能做到同樣的操作。&lt;/p&gt;

&lt;p&gt;如你所見，使用 Ruby 光是開個&lt;a href="https://zh.wikipedia.org/zh-tw/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"&gt;檔案描述符&lt;/a&gt;（以下簡稱 FD）就有數幾種方法，令人眼花撩亂，常看到的是有人用同一招打天下，卻一直沒有去了解其他的方法與其是用情境，有些可惜，而這篇文章將透過由下而上的方式，一一介紹、示範它們的差別和使用。&lt;/p&gt;

&lt;h1 id="ionew"&gt;IO.new&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;IO&lt;/code&gt; 類別是 Ruby 對 FD 進行讀寫操作的一切基礎，我們可以用 &lt;code&gt;File&lt;/code&gt; 來操作是因為 &lt;code&gt;File&lt;/code&gt; 繼承自 &lt;code&gt;IO&lt;/code&gt;，只是稍嫌麻煩些。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IO.new&lt;/code&gt; 的第一個參數必須是 FD，或在 Windows 下則稱 &lt;a href="https://zh.wikipedia.org/zh-hant/%E5%8F%A5%E6%9F%84"&gt;句柄&lt;/a&gt;，無論何者都只是一個數字。&lt;/p&gt;

&lt;p&gt;如果你已知標準輸入與標準輸出的檔案描述符分別為 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt;，不妨實驗一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;stdin = IO.new(0)
stdout = IO.new(1)
stdout.puts "what's your name?"
name = stdin.gets.chomp!
stdout.puts "hello, #{name}!"

# what's your name?
# tony
# hello, tony!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外可用 &lt;code&gt;IO.sysopen&lt;/code&gt; 來取得檔案的 FD，這其實就是 &lt;code&gt;File&lt;/code&gt; 類別的做法，&lt;code&gt;File&lt;/code&gt; 只是隱藏此細節罷了：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;fd = IO.sysopen('file.txt', 'w') #=&amp;gt; 3
io = IO.new(fd)
io.puts 'hello!'
io.close
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一個例子是透過 &lt;code&gt;/dev/tty&lt;/code&gt; 寫到終端：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;fd = IO.sysopen('/dev/tty', 'w')
io = IO.new(fd,'w')
puts 'Hello'
io.puts 'World'
io.close

# Hello
# World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;筆者在這裡提醒要小心選擇正確的 tty 檔案，萬一不慎選到其他使用者的，執行上述程式碼就會在他人的終端畫面上印出一堆垃圾。&lt;/p&gt;

&lt;p&gt;如果對 tty 的概念不熟悉，可以參考&lt;a href="http://tldp.org/HOWTO/Text-Terminal-HOWTO-7.html"&gt;這篇文章&lt;/a&gt;，在 UN*X 的世界裡面，所有裝置都是一個檔案，終端也是一個檔案，自然可以像檔案一樣對其進行讀寫。&lt;/p&gt;

&lt;h1 id="ioopen"&gt;IO.open&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;IO.open&lt;/code&gt; 沒什麼新奇之處，它只是 &lt;code&gt;IO.new&lt;/code&gt; 加上 block 的擴充版本，若無使用 block 時，與 &lt;code&gt;IO.new&lt;/code&gt; 無異，最後會回傳 &lt;code&gt;IO&lt;/code&gt; 物件；但若與 block 使用，有兩個特點：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;IO&lt;/code&gt; 物件會在 block 結束時被自動關閉（意即不需要寫 &lt;code&gt;IO#close&lt;/code&gt;）。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IO.open&lt;/code&gt; 最後回傳的不再是 &lt;code&gt;IO&lt;/code&gt; 物件，而是 block 的最後執行結果。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id="iopopen"&gt;IO.popen&lt;/h1&gt;

&lt;p&gt;有曾好奇過市面上的 CI 是怎麼做到即時顯示終端上的文字嗎？以 Travis CI 為例，下圖那塊黑色區塊中的內容是即時輸出的：&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/travis.png" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;或者曾想過在自己的網站上執行外部的指令，並且即時呈現給使用者呢？若你有在 Ruby 中呼叫其他系統指令的經驗（例如 &lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;cat&lt;/code&gt;、&lt;code&gt;bundle install&lt;/code&gt; 等等），那應該對 &lt;code&gt;system&lt;/code&gt;、&lt;code&gt;%x{}&lt;/code&gt; 或是 &lt;code&gt;``&lt;/code&gt; 不陌生：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;system 'date' # =&amp;gt; true, false or nil
%x{date}      # =&amp;gt; the standard output of the running cmd
`date`        # =&amp;gt; as above
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而 &lt;code&gt;system&lt;/code&gt; 只根據指令執行結果成功與否回傳布林值，無法直接存取子程序輸出的結果；&lt;code&gt;%x{}&lt;/code&gt; 會以字串形式回傳結果，但必須等到子程序執行結束後才會回傳整個字串，無法即時監控子程序的標準輸出。&lt;/p&gt;

&lt;p&gt;相較於 &lt;code&gt;%x{}&lt;/code&gt; 回傳完整的字串，&lt;code&gt;IO.popen&lt;/code&gt; 則是回傳 &lt;code&gt;IO&lt;/code&gt; 物件。為了比較出差異，這裡就拿 &lt;code&gt;ping&lt;/code&gt; 指令為例，因為該指令會不斷在終端畫面上輸出訊息，直到使用者手動停止，如果使用 &lt;code&gt;%x{}&lt;/code&gt; 的話，Ruby 程式將會卡在該處，且因準備要回傳的字串越來越長，最後導致記憶體不夠用或程式會卡到海枯石爛。&lt;/p&gt;

&lt;p&gt;相較下操作 &lt;code&gt;IO&lt;/code&gt; 物件就可以一次讀一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;# puts %x{ping www.alphacamp.co} # don't do this
io = IO.popen('ping www.alphacamp.co')
while line = io.gets
  print line
end
# PING www.alphacamp.co (198.41.206.122): 56 data bytes
# 64 bytes from 198.41.206.122: icmp_seq=0 ttl=58 time=2.794 ms
# 64 bytes from 198.41.206.122: icmp_seq=1 ttl=58 time=4.876 ms
# 64 bytes from 198.41.206.122: icmp_seq=2 ttl=58 time=7.081 ms
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;當然這還離真正做出一個在網頁上呈現終端執行畫面的功能還很遠，例如上述的程式碼卡在一個無窮迴圈裡面，&lt;br /&gt;
你可能會想針對 IO 阻塞問題做出一些改善，像是配合 &lt;code&gt;IO.select&lt;/code&gt; 或是 &lt;code&gt;IO#read_nonblock&lt;/code&gt; 等，但純屬延伸議題，不在本章範圍，有機會筆者會在另一篇章中分享怎麼做到 :)&lt;/p&gt;

&lt;h1 id="filenew-與-fileopen"&gt;File.new 與 File.open&lt;/h1&gt;

&lt;p&gt;這兩個方方法就是大家耳熟能詳的開檔方案了，它們和 &lt;code&gt;IO.new&lt;/code&gt; 與 &lt;code&gt;IO.open&lt;/code&gt; 幾乎一樣，只差在覆寫了 &lt;code&gt;initialize&lt;/code&gt; 方法，使其接受的參數不再是 FD 而是檔案的路徑字串。&lt;code&gt;File.new&lt;/code&gt; 回傳值也和 &lt;code&gt;IO.new&lt;/code&gt; 一樣是 &lt;code&gt;IO&lt;/code&gt; 物件；在 &lt;code&gt;File.open&lt;/code&gt; 與 block 同時使用的情況下也和 &lt;code&gt;IO.open&lt;/code&gt; 一樣，會自動關檔，且回傳 block 的最後執行結果。&lt;/p&gt;

&lt;h1 id="kernelopen"&gt;Kernel.open&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Kernel.open&lt;/code&gt; 大概是最萬用的方法了，留在最後講是因為它是 &lt;code&gt;IO.popen&lt;/code&gt; 與 &lt;code&gt;File.open&lt;/code&gt; 的合體，除此也接受擁有 &lt;code&gt;#to_open&lt;/code&gt; 方法的物件。&lt;/p&gt;

&lt;p&gt;當傳入一個物件給 &lt;code&gt;Kernel.open&lt;/code&gt; 時，處理的優先續如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;檢查該物件是否有 &lt;code&gt;#to_open&lt;/code&gt; 方法，有則直接呼叫以取得 &lt;code&gt;IO&lt;/code&gt; 物件。&lt;/li&gt;
  &lt;li&gt;如果物件是字串且開頭是 &lt;code&gt;|&lt;/code&gt;，則去掉 &lt;code&gt;|&lt;/code&gt;，剩下丟給 &lt;code&gt;IO.popen&lt;/code&gt; 處理。&lt;/li&gt;
  &lt;li&gt;最後交給 &lt;code&gt;File.open&lt;/code&gt; 處理&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="to_open"&gt;to_open&lt;/h2&gt;

&lt;p&gt;關於 &lt;code&gt;#to_open&lt;/code&gt; Ruby 文件上沒有一處提及，只記載在 Ruby 原始碼中。實作的時候必要回傳 &lt;code&gt;IO&lt;/code&gt; 物件即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class Foo
  def to_open
    puts 'Foo#to_open is here'
    File.open('test.txt') # =&amp;gt; IO instance
  end
end

open Foo.new do |io|
  # ...
  # io will be closed automatically
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="該用哪個"&gt;該用哪個？&lt;/h1&gt;

&lt;p&gt;這沒有什麼強制的規範，畢竟 Ruby 是一個自由的程式語言，比較接近 Perl，和一板一眼的 Python 不太一樣（Only one way to do it）。不過筆者建議大原則是盡量使用易讀易寫的 API 來完成工作，如果有細節需要處理再用其他的方法。例如一般開檔就使用 &lt;code&gt;File.open&lt;/code&gt; 或是 &lt;code&gt;Kernel.open&lt;/code&gt; 即可，需要存取 FD 則改用 &lt;code&gt;IO.open&lt;/code&gt;，若要手動關檔再考慮 &lt;code&gt;File.new&lt;/code&gt; 或 &lt;code&gt;IO.new&lt;/code&gt;。另外也不要特別使用 &lt;code&gt;Kernel.open&lt;/code&gt; 調用 &lt;code&gt;IO.popen&lt;/code&gt; 的奇怪語法（&lt;code&gt;|&lt;/code&gt;），這會降低程式碼的可讀性，不符合易讀易寫。像 &lt;code&gt;IO.popen('date')&lt;/code&gt; 就比 &lt;code&gt;Kernel.open('|date')&lt;/code&gt; 好懂多了。&lt;/p&gt;

&lt;p&gt;另一個原則是程式碼的一致性，如果團隊開檔案都使用 &lt;code&gt;File.open&lt;/code&gt;，那就盡量避免特立獨行使用 &lt;code&gt;Kernel.open&lt;/code&gt;，反之亦然。&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>Ziltag Beta 啟動</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/03/01/ziltag-start/"/>
    <id>https://tonytonyjan.net/2016/03/01/ziltag-start/</id>
    <published>2016-03-01T00:53:00+08:00</published>
    <updated>2018-04-21T10:55:55+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;筆者很久以前曾希望有個服務可以在圖片上自由的加上各種資訊，那是在看漫畫的時候，心想如果可以在某些分鏡加上自己的評論並與網友們互動，效果應該不錯，不料今天出自夥伴與自己的手，世事難料啊XD&lt;/p&gt;

&lt;h1 id="zillion-tags-ziltag"&gt;Zillion Tags, Ziltag&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://ziltag.com"&gt;Ziltag&lt;/a&gt; 的目的是希望在現有的圖片、影片等多媒體上面，創要一種新的社交互動方式：你可以在任何圖片的任何地方標籤上任何資訊，可以是一句話、一個人名、一段連結影片等，而每個標籤都可以是個討論串。&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;筆者很久以前曾希望有個服務可以在圖片上自由的加上各種資訊，那是在看漫畫的時候，心想如果可以在某些分鏡加上自己的評論並與網友們互動，效果應該不錯，不料今天出自夥伴與自己的手，世事難料啊XD&lt;/p&gt;

&lt;h1 id="zillion-tags-ziltag"&gt;Zillion Tags, Ziltag&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://ziltag.com"&gt;Ziltag&lt;/a&gt; 的目的是希望在現有的圖片、影片等多媒體上面，創要一種新的社交互動方式：你可以在任何圖片的任何地方標籤上任何資訊，可以是一句話、一個人名、一段連結影片等，而每個標籤都可以是個討論串。&lt;/p&gt;



&lt;p&gt;如果你的設備有滑鼠指標（Beta 尚未支援手機），只要將它移動到下面這張圖片就可以理解這個服務在做什麼：&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/piano.jpg" alt="tonytonyjan is playing the piano" /&gt;&lt;/p&gt;

&lt;p&gt;有別於其他平台，Ziltag 是以提供腳本的方式給那些想要在網站上提供多元互動的站長們使用，這些站長們可能是部落客、攝影師、畫家、設計師、美食家、探險家等。除了創造與讀者的新互動之外，他們也能透過標籤傳達讀者可能感興趣的資訊，例如商品的價錢、植物的介紹、食材廣告、英語單字教學等等，使用方式依照使用者的創意可以十分多元。&lt;/p&gt;

&lt;h1 id="成為-ziltag-夥伴"&gt;成為 Ziltag 夥伴&lt;/h1&gt;

&lt;p&gt;成為使用者很容易，當你在聆聽筆者的音樂拙作時，就已經是 Ziltag 使用者了，如果想進一步留下評語（手下留情），直接留言即可，並不需要離開筆者的網站。相對的，你若有自己的網站，且也希望提供你的讀者不同的體驗，則必須透過 &lt;a href="https://ziltag.com"&gt;Ziltag&lt;/a&gt; 網站註冊並索取腳本，不妨今天就來玩玩看吧 :)&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>Rails on webpack</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/02/10/rails-on-webpack/"/>
    <id>https://tonytonyjan.net/2016/02/10/rails-on-webpack/</id>
    <published>2016-02-10T22:35:00+08:00</published>
    <updated>2018-04-21T10:55:55+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;記得筆者在去年於 RubyConf Taiwan 講的題目「&lt;a href="https://youtu.be/0mphTtsekkI?t=2m59s"&gt;還給前端工程師一片天空&lt;/a&gt;」中提到如何整合 Rails 與 Node.js 世界的工具，&lt;a href="/slides/2015-09-11-return-front-end-back-to-front-end-developers/slides.pdf"&gt;投影片在此&lt;/a&gt;。雖然 &lt;a href="https://github.com/webpack/webpack"&gt;webpack&lt;/a&gt; 正夯，但礙於筆者當時沒去研究，使用的工具仍是上一代的 gulp、bower，所幸議程也有相關的講題，如&lt;strong&gt;何澤清&lt;/strong&gt;前輩的「&lt;a href="https://www.youtube.com/watch?v=vbdVuEctCCQ"&gt;gem 'webpack-rails'&lt;/a&gt;」。&lt;/p&gt;

&lt;p&gt;只是經過筆者幾番研究之後，覺得整合這兩樣東西似乎不需要像網路上找到的各種教學文或是 gem 搞的那樣複雜，所以想藉這篇文章分享自己的做法（但並不保留 sprockets）。在那之前，先分享一些小知識：&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;記得筆者在去年於 RubyConf Taiwan 講的題目「&lt;a href="https://youtu.be/0mphTtsekkI?t=2m59s"&gt;還給前端工程師一片天空&lt;/a&gt;」中提到如何整合 Rails 與 Node.js 世界的工具，&lt;a href="/slides/2015-09-11-return-front-end-back-to-front-end-developers/slides.pdf"&gt;投影片在此&lt;/a&gt;。雖然 &lt;a href="https://github.com/webpack/webpack"&gt;webpack&lt;/a&gt; 正夯，但礙於筆者當時沒去研究，使用的工具仍是上一代的 gulp、bower，所幸議程也有相關的講題，如&lt;strong&gt;何澤清&lt;/strong&gt;前輩的「&lt;a href="https://www.youtube.com/watch?v=vbdVuEctCCQ"&gt;gem 'webpack-rails'&lt;/a&gt;」。&lt;/p&gt;

&lt;p&gt;只是經過筆者幾番研究之後，覺得整合這兩樣東西似乎不需要像網路上找到的各種教學文或是 gem 搞的那樣複雜，所以想藉這篇文章分享自己的做法（但並不保留 sprockets）。在那之前，先分享一些小知識：&lt;/p&gt;



&lt;h1 id="asset_path-知多少"&gt;asset_path 知多少？&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;#asset_path&lt;/code&gt; 是 Rails 中其中一個底層 API，許多 helper 如 &lt;code&gt;#image_tag&lt;/code&gt; 等都會調用，而若沒有特別查閱原始碼，大概不多人知道 &lt;code&gt;asset_path('/app.js')&lt;/code&gt; 和 &lt;code&gt;asset_path('app.js')&lt;/code&gt; 差了一個斜線會影響結果，至於差在哪就讓我們節錄部份原始碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;def asset_path(source, options = {})
  # ...
  if source[0] != ?/
    source = compute_asset_path(source, options)
  end
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sprockets 其實有偷偷去複寫 &lt;code&gt;#compute_asset_path&lt;/code&gt;，也就是說當傳入 &lt;code&gt;"/app.js"&lt;/code&gt;，assets pipeline 是不會運作的，但若傳入 &lt;code&gt;"app.js"&lt;/code&gt;，在 sprockets &lt;code&gt;#compute_asset_path&lt;/code&gt; 的加持下結果會長的像 &lt;code&gt;/assets/app-c5bd5cb45ee76432b26a5dfb28e01b59.js?body=1&lt;/code&gt;；反之若 &lt;code&gt;"app.js"&lt;/code&gt; 檔案不存在，或者根本就沒安裝 sprockets，那就退回原型得到 &lt;code&gt;"/app.js"&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以只要我們複寫的 &lt;code&gt;#compute_asset_path&lt;/code&gt; 能算出 webpack 產生在 &lt;code&gt;public/assets&lt;/code&gt; 中的正確路徑，其實不用更改任何 API，就可以輕鬆整合 webpack。而 &lt;code&gt;#javascript_include_tag&lt;/code&gt;、&lt;code&gt;#stylesheet_link_tag&lt;/code&gt;、&lt;code&gt;#image_tag&lt;/code&gt; 等 helper 都可以照常使用。&lt;/p&gt;

&lt;h1 id="webpack-json"&gt;webpack –json&lt;/h1&gt;

&lt;p&gt;sprockets 在編譯後會產生 &lt;code&gt;manifest.json&lt;/code&gt;，裡面有 asset 原始路徑與其計算後的路徑資訊（例如 &lt;code&gt;app.js&lt;/code&gt; 對應到 &lt;code&gt;/assets/app-c5bd5cb45ee76432b26a5dfb28e01b59.js&lt;/code&gt;，以 Hash 儲存），好處是 Rails 可以透過讀檔取得計算後的路徑結果，不須透過 sprockets，所以為了增加效能，這個檔案在 production 環境中是必要的，而在 development 環境中，由於 assets 的路徑是及時透過 sprockets 得出，所以並不需要這個檔案。&lt;/p&gt;

&lt;p&gt;此外 sprockets 在 controller 與 router 中也動了手腳，這也是為什麼專案中 &lt;code&gt;public/assets&lt;/code&gt; 明明沒東西，而在 development 環境下中送出像是 &lt;code&gt;/assets/ooxx.js&lt;/code&gt; 的請求卻仍可以正常運作的原因。&lt;/p&gt;

&lt;p&gt;只是 webpack 畢竟是 Node.js 世界的產物，無法篡改 Rails controller 與 router，好消息是 &lt;code&gt;webpack --json&lt;/code&gt; 會產生一個跟 &lt;code&gt;manifest.json&lt;/code&gt; 類似的檔案（官方稱之為 stats file）。所以只要在 &lt;code&gt;webpack.config.js&lt;/code&gt; 中加入產生 stats 的 plugin，再用 &lt;code&gt;webpack --watch&lt;/code&gt; 來開發就已經綽綽有餘了，例如我們在專案的根目錄下產生 &lt;code&gt;stats.json&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-js"&gt;plugins = [
  function() {
    this.plugin('done', function(stats) {
      require('fs').writeFileSync(__dirname + '/stats.json', JSON.stringify(stats.toJson()))
    })
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="範例專案"&gt;範例專案&lt;/h1&gt;

&lt;p&gt;筆者&lt;a href="https://github.com/tonytonyjan/rails_on_webpack"&gt;在 Github 實作了一個範例&lt;/a&gt;，重點只在兩個檔案： &lt;a href="https://github.com/tonytonyjan/rails_on_webpack/blob/master/app/helpers/webpack_helper.rb"&gt;app/helpers/webpack_helper.rb&lt;/a&gt; 與 &lt;a href="https://github.com/tonytonyjan/rails_on_webpack/blob/master/lib/webpack_stats.rb"&gt;lib/webpack_stats.rb&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack_stats.rb&lt;/code&gt; 負責載入 webpack 產生的 &lt;code&gt;stats.json&lt;/code&gt;，經過處理之後產生一個 assets hash，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;{
  'app.js' =&amp;gt; '/assets/app.js',
  'app.css' =&amp;gt; '/assets/app-c5bd5cb45ee76432b26a5dfb28e01b59.css' # 也支援 hash 尾綴
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（限制是 webpack 必須遵守檔名格式為 &lt;code&gt;filename-hash.extname&lt;/code&gt; 或是 &lt;code&gt;filename.extname&lt;/code&gt;。）&lt;/p&gt;

&lt;p&gt;而這個 assets hash 將被用在 &lt;code&gt;#compute_asset_path&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;# app/helpers/webpack_helper.rb
require 'webpack_stats'
module WebpackHelper
  def compute_asset_path source, options = {}
    WebpackStats.assets[source] || super
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大功告成！老實說這樣就已經能完美運作了，不用安裝什麼 gem，實測用來寫 react 也不用安裝 &lt;a href="https://github.com/reactjs/react-rails"&gt;react-rails&lt;/a&gt;。而剩下的問題已經不關整合的事，像要加入 SASS、CoffeeScript 或是 Font Awesome 等，或是在 production 下要壓縮 JavaScript 並且分離 CSS 檔案等，這取決開發者對 webpack 的掌握。&lt;/p&gt;

&lt;p&gt;至於只在 production 中分離 CSS 檔案，裡面可以這樣寫：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;%= stylesheet_link_tag 'application', media: 'all' if Rails.env.production? %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至於為何要這樣做，可參考 extract-text-webpack-plugin 的 &lt;a href="https://github.com/webpack/extract-text-webpack-plugin/blob/master/README.md"&gt;README&lt;/a&gt; 提到的優缺點。&lt;/p&gt;

&lt;h1 id="我就是要-gem"&gt;我就是要 gem&lt;/h1&gt;

&lt;p&gt;其實筆者也是有做啦⋯⋯如果真的覺得那兩個檔案很麻煩，可以安裝 &lt;a href="https://github.com/tonytonyjan/webpack_stats"&gt;webpack_stats&lt;/a&gt;，這除了可以用在 Rails，也可以當一般 webpack stats 的 loader 使用（用在 Rails 之外的地方）。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>來自 chef.io 的小禮物</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/01/30/a-gift-from-chef-io/"/>
    <id>https://tonytonyjan.net/2016/01/30/a-gift-from-chef-io/</id>
    <published>2016-01-30T14:56:00+08:00</published>
    <updated>2018-04-21T10:55:55+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;筆者在開原世界裡面也打滾一陣子，貢獻過大小專案如 Rails、Ruby 等，也收過一些獎勵如比特幣、質數幣，但這次的禮物還蠻特別的，讓人忍不住想要多發一篇網誌：&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/chef-2.jpg" alt=""&gt;&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;筆者在開原世界裡面也打滾一陣子，貢獻過大小專案如 Rails、Ruby 等，也收過一些獎勵如比特幣、質數幣，但這次的禮物還蠻特別的，讓人忍不住想要多發一篇網誌：&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/chef-2.jpg" alt="" /&gt;&lt;/p&gt;



&lt;p&gt;&lt;a href="http://chef.io/"&gt;chef.io&lt;/a&gt; 這種方式還頗逗趣的，比起錢，筆者似乎還比較喜歡這種可愛方式（完全中招啊）。除了感謝狀之外，還有一些小貼紙，可惜筆者沒有在筆電上面加貼紙的習慣，只能收在抽屜裡了。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/chef.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;唯一美中不足的地方就是國名寫了「Province of China」讓人不是很舒服，如果只寫「China」或「Republic of China」筆者是還勉強可以接受，畢竟現在中國正在內戰中嘛，只是搞不清兩個政府的領土就實在有點不應該（但無論是哪一個 China，當然還是寫 Taiwan 最好聽了）。&lt;/p&gt;

&lt;h1 id="chefconf-2016"&gt;ChefConf 2016&lt;/h1&gt;

&lt;p&gt;題外話，最近筆者收到一封寄給貢獻者的 &lt;a href="https://chefconf.chef.io"&gt;ChefConf 2016&lt;/a&gt; 邀請信，早鳥票可以省 400 鎂，然後如果是 chef 貢獻者的話還可以額外省 $295 鎂，害得筆者頗心動，但即便如此筆者仍無法負擔高額的機票與住宿的費用，如果有誰需要這筆優惠的話，還請與筆者聯絡，不要讓這筆錢浪費了，感激不盡 :)&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>對不起，我把馬英九放進 Ruby 2.3 了</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/01/07/there-are-politicians-in-ruby-2-3-0/"/>
    <id>https://tonytonyjan.net/2016/01/07/there-are-politicians-in-ruby-2-3-0/</id>
    <published>2016-01-07T23:27:00+08:00</published>
    <updated>2018-04-21T10:55:55+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img src="/images/ma.png" alt=""&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這世界所有升級到 Ruby 2.3 的伺服器，皆可以得到英九的庇佑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;身為一個 Ruby 語言的教徒，這個聖誕節最令人興奮的莫過於 &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3&lt;/a&gt; 的發表了，不過這次由於筆者的緣故，意外讓台灣的政治人物們走進了 Ruby 原始碼中，究竟是怎麼回事呢XD&lt;/p&gt;

&lt;p&gt;百聞不如一見，各位不妨...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img src="/images/ma.png" alt="" /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這世界所有升級到 Ruby 2.3 的伺服器，皆可以得到英九的庇佑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;身為一個 Ruby 語言的教徒，這個聖誕節最令人興奮的莫過於 &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3&lt;/a&gt; 的發表了，不過這次由於筆者的緣故，意外讓台灣的政治人物們走進了 Ruby 原始碼中，究竟是怎麼回事呢XD&lt;/p&gt;

&lt;p&gt;百聞不如一見，各位不妨可以先自己找看看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -s https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.0.tar.gz | tar -xz
$ grep -hr -C 3 馬英九 ruby-2.3.0
def test_jarowinkler_distance_with_utf8_strings
  assert_distance 0.9818, '變形金剛4:絕跡重生', '變形金剛4: 絕跡重生'
  assert_distance 0.8222, '連勝文',             '連勝丼'
  assert_distance 0.8222, '馬英九',             '馬英丸'
  assert_distance 0.6667, '良い',               'いい'
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="did-you-mean"&gt;Did You Mean?&lt;/h1&gt;

&lt;p&gt;Ruby 2.3 新增了錯字校正功能，會在我們打錯字的時候提醒我們，例如將 &lt;code&gt;#byebug&lt;/code&gt; 誤寫成 &lt;code&gt;#buybug&lt;/code&gt;。在過去 Ruby 只會擲出 &lt;code&gt;NameError&lt;/code&gt; 異常，並夾帶一串文字訊息，現在則除了擲出異常外，也會猜測你原本想輸入的文字：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;require 'byebug'
buybug
# NameError: undefined local variable or method `buybug' for main:Object
# Did you mean?  byebug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡（煒航）言之這就是 Ruby 的 spell check 功能，是來自 &lt;a href="https://twitter.com/yuki24"&gt;@yuki24&lt;/a&gt; 製作的 Ruby gem &lt;a href="https://github.com/yuki24/did_you_mean"&gt;did_you_mean&lt;/a&gt;，當 &lt;code&gt;NameError&lt;/code&gt; 發生時，該 gem  會嘗試找出其他相似的字。&lt;/p&gt;

&lt;h1 id="jaro-winkler-距離"&gt;Jaro-Winkler 距離&lt;/h1&gt;

&lt;p&gt;對於兩個字串之間的相似度的比對有許多相關的演算法，諸如 &lt;a href="https://www.wikiwand.com/en/Hamming_distance"&gt;Hamming&lt;/a&gt;、&lt;a href="https://www.wikiwand.com/en/Levenshtein_distance"&gt;Levenshtein&lt;/a&gt;、&lt;a href="https://www.wikiwand.com/en/Jaro%E2%80%93Winkler_distance"&gt;Jaro-Winkler&lt;/a&gt; 等，而對於短字串的比較尤以 Jaro-Winkler 普遍被認為較為精準。該演算法當初在醫療機構內，為了確認病患姓名而被發明出來的，如今卻已經在諸多領域中得到廣泛的使用，這也是 did_you_mean 所使用的核心算法。&lt;a href="https://github.com/yuki24/did_you_mean/commit/15f8b049ce2a04957d0975027f2cbf8e93b0ad59"&gt;在 Gemfile 中&lt;/a&gt;能找到一段 &lt;a href="https://github.com/tonytonyjan/jaro_winkler"&gt;jaro_winkler&lt;/a&gt; 的引用，這即是筆者的貢獻。&lt;/p&gt;

&lt;p&gt;只是不料當 did_you_mean 被移植到 Ruby 時，連筆者寫下的支援 UTF-8 的測試也都&lt;a href="https://github.com/yuki24/did_you_mean/blob/b2e4b3c590a2fd1b08f37a9d976e4dfe97533c68/test/edit_distance/jaro_winkler_test.rb"&gt;一併被移植過去了&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id="大選近矣"&gt;大選近矣&lt;/h1&gt;

&lt;p&gt;話說最近正逢總統大選，也發生一些趣事，有些國民黨的支持者在國民黨候選人的廣告上貼上馬英九的貼紙，聽說&lt;a href="https://www.ptt.cc/bbs/Gossiping/M.1451986445.A.CF1.html"&gt;就被移送法辦了&lt;/a&gt;，後續如何筆者不是很清楚。但現在因為筆者的關係，讓世界上的許多人的伺服器硬碟的某處存著一個馬英九，希望筆者不會有什麼遭遇才是。萬一，哪天筆者再也沒有出現在臉書上，傳訊也沒回，請幫筆者轉達家母「我愛她」。另外不自殺聲明已經放在 Github 上了，萬一有不測，請幫筆者討回公道，萬分感謝！&lt;/p&gt;

&lt;p&gt;話說回來，就算歐巴馬會寫程式好了，但不見得名字會在原始碼裡面呢，台灣是不是很厲害呢www&lt;/p&gt;

</content>
  </entry>
</feed>
