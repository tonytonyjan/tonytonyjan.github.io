<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不歸路</title>
  <subtitle>簡煒航的個人部落格</subtitle>
  <id>https://tonytonyjan.net</id>
  <link href="https://tonytonyjan.net"/>
  <link href="https://tonytonyjan.net/feed.xml" rel="self"/>
  <updated>2018-07-08T14:57:00+08:00</updated>
  <author>
    <name>大兜</name>
  </author>
  <entry>
    <title>cron 如何忽略系統的環境變數</title>
    <link rel="alternate" href="https://tonytonyjan.net/2018/07/08/how-cron-omit-environment-variables/"/>
    <id>https://tonytonyjan.net/2018/07/08/how-cron-omit-environment-variables/</id>
    <published>2018-07-08T14:57:00+08:00</published>
    <updated>2018-07-10T09:40:37+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;這大概是碼農們時常會遇到的問題之一了，明明設定好的環境變數在殼層操作沒有問題，但是同樣的指令在 cron 卻會出現找不到該指令或找不到環境變數的錯誤。&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;這大概是碼農們時常會遇到的問題之一了，明明設定好的環境變數在殼層操作沒有問題，但是同樣的指令在 cron 卻會出現找不到該指令或找不到環境變數的錯誤。&lt;/p&gt;



&lt;h1 id="cron-的環境變數去哪了"&gt;cron 的環境變數去哪了？&lt;/h1&gt;

&lt;p&gt;為了偵錯，這時筆者通常會在 cron 腳本設定：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* * * * * env &amp;gt; /var/log/env.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;靜待一分鐘後觀察 &lt;code&gt;/var/log/env.log&lt;/code&gt; 的內容，以決定要補上那些缺漏的環境變數。&lt;/p&gt;

&lt;p&gt;筆者將以類似這樣技巧來重現問題與實驗，並且透過以下 &lt;code&gt;Dockerfile&lt;/code&gt; 作為基礎：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-dockerfile"&gt;FROM debian:stretch-slim
RUN echo 'deb-src http://deb.debian.org/debian stretch main' &amp;gt;&amp;gt; /etc/apt/sources.list
RUN apt-get update
RUN apt-get install -y procps cron vim dpkg-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="問題重現"&gt;問題重現&lt;/h1&gt;

&lt;p&gt;透過 &lt;code&gt;docker run -e FOO=BAR&lt;/code&gt; 可以將環境變數 &lt;code&gt;FOO=BAR&lt;/code&gt; 設定在 Docker container 的 init 程序，由於 init 程序是 UN*X 啟動時開天闢地的第一個程序，其他的程序都是由此程序衍生出來，所以除非做了特別設定，否則所有程序能繼承到 &lt;code&gt;FOO&lt;/code&gt; 環境變數。&lt;/p&gt;

&lt;p&gt;讓我們驗證一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -e FOO=BAR IMAGE_NAME env
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=20794784a3ce
FOO=BAR
HOME=/root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我們可以看到 &lt;code&gt;FOO=BAR&lt;/code&gt; 確實傳進去了，接著，我們再用 cron 做另外一個實驗：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -e FOO=BAR IMAGE_NAME sh -c 'echo \'* * * * * env &amp;gt; /var/log/env.log\' | crontab - &amp;amp;&amp;amp; cron &amp;amp;&amp;amp; sleep $((62 - $(date +%S) )) &amp;amp;&amp;amp; cat /var/log/env.log'
HOME=/root
LOGNAME=root
PATH=/usr/bin:/bin
SHELL=/bin/sh
PWD=/root
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;sleep $((62 - $(date +%S) ))&lt;/code&gt; - 指的是「睡到秒針到 2」。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;從印出的結果發現，同樣是 &lt;code&gt;env&lt;/code&gt; 指令，在殼層執行與 cron 執行的結果並不一致。首先 &lt;code&gt;FOO=BAR&lt;/code&gt; 消失了，甚至 &lt;code&gt;PATH&lt;/code&gt; 裡的路徑也差異極大，從原本的 &lt;code&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&lt;/code&gt; 變成僅剩下 &lt;code&gt;/usr/bin:/bin&lt;/code&gt;，這可以說明為何許多人在 cron 腳本中使用指令時，習慣使用絕對路徑，或者在腳本上方定義明確定義 &lt;code&gt;PATH&lt;/code&gt; 變數。&lt;/p&gt;

&lt;h2 id="cron-的-forking-過程"&gt;cron 的 forking 過程&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;那麼 cron 是在哪個階段把環境變數清掉的呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由於筆者深受「知其然不知其所以然」的痛苦，不得不調查 cron 到底在搞什麼鬼。在此推薦一個好用的指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sh"&gt;ps wwefxo pid,ppid,command
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ww&lt;/code&gt; - 無視終端機的寬度，將結果都印出&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;e&lt;/code&gt; - 印出環境變數&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;f&lt;/code&gt; - 以樹狀的方式呈現&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;x&lt;/code&gt; - 印出不被任何終端所控制的程序，例如守護行程&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;o pid,ppid,command&lt;/code&gt; - 只印出程序的 pid、ppid、command&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多用法請參考 &lt;a href="https://linux.die.net/man/1/ps"&gt;man ps&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用同樣的技巧再作一次實驗：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -e FOO=BAR IMAGE_NAME sh -c 'echo \'* * * * * ps wwefxo pid,ppid,command &amp;gt; /var/log/ps.log\' | crontab - &amp;amp;&amp;amp; cron &amp;amp;&amp;amp; sleep $((62 - $(date +%S) )) &amp;amp;&amp;amp; cat /var/log/ps.log'
  PID  PPID COMMAND
    1     0 sh -c echo '* * * * * ps wwefxo pid,ppid,command &amp;gt; /var/log/ps.log' | crontab - &amp;amp;&amp;amp; cron &amp;amp;&amp;amp; sleep $((62 - $(date +%S) )) &amp;amp;&amp;amp; cat /var/log/ps.log PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=87736bfa1426 FOO=BAR HOME=/root
   11     1 cron HOSTNAME=87736bfa1426 HOME=/root PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin FOO=BAR PWD=/
   14    11  \_ CRON HOSTNAME=87736bfa1426 HOME=/root PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin FOO=BAR PWD=/
   15    14      \_ /bin/sh -c ps wwefxo pid,ppid,command &amp;gt; /var/log/ps.log SHELL=/bin/sh HOME=/root PATH=/usr/bin:/bin LOGNAME=root
   16    15          \_ ps wwefxo pid,ppid,command HOME=/root LOGNAME=root PATH=/usr/bin:/bin SHELL=/bin/sh PWD=/root
   13     1 sleep 57 HOSTNAME=87736bfa1426 HOME=/root PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin FOO=BAR PWD=/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可見當 cron 執行一份工作項目時，整體程序的祖孫結構如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init -&amp;gt; cron -&amp;gt; cron -&amp;gt; sh -&amp;gt; cron job
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cron 會額外再 fork 一次自己，然後再執行 &lt;code&gt;sh -c "JOB STRING"&lt;/code&gt;，而環境變數正是在這個階段消失的。&lt;/p&gt;

&lt;p&gt;截至目前為止我們僅知道執行 &lt;code&gt;sh&lt;/code&gt; 時，環境變數已經被改變，無法說明為何環境變數會莫名奇妙消失。筆者起初猜測是 cron 有使用 &lt;code&gt;env -i&lt;/code&gt; 指令，但從程序樹的結果來看則不然。&lt;/p&gt;

&lt;p&gt;無計可施，只好翻了一下 cron 的原始碼，在 &lt;code&gt;do_command.c&lt;/code&gt; 找到了線索：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -e FOO=BAR -w /usr/src -v (pwd)/src:/usr/src IMAGE_NAME apt-get source cron
$ grep -C 3 --color '"-c"' (find src -name do_command.c)
                            }
                        }
#endif
                        execle(shell, shell, "-c", e-&amp;gt;cmd, (char *)0, jobenv);
                        fprintf(stderr, "%s: execle: %s\n", shell, strerror(errno));
                        _exit(ERROR_EXIT);
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原來 cron 在執行 &lt;code&gt;sh&lt;/code&gt; 指令時，使用了 &lt;code&gt;execle&lt;/code&gt;，且在最後的參數傳入了自訂的環境變數 &lt;code&gt;jobenv&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;引用一段 &lt;code&gt;execle&lt;/code&gt; 的 &lt;code&gt;man&lt;/code&gt; 頁面：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The execle() and execvpe() functions allow the caller to specify the environment of the executed program via the argument envp. The envp argument is an array of pointers to null-terminated strings and must be terminated by a NULL pointer. The other functions take the environment for the new process image from the external variable environ in the calling process.  - https://linux.die.net/man/3/execle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然後於是筆者在 &lt;code&gt;entry.c&lt;/code&gt; 找到了設定環境變數的地方&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep -B 2 --color 'env_set' (find src -name entry.c)
        if (!env_get("SHELL", e-&amp;gt;envp)) {
                snprintf(envstr, MAX_ENVSTR, "SHELL=%s", _PATH_BSHELL);
                if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
--
        if (!env_get("HOME", e-&amp;gt;envp)) {
                snprintf(envstr, MAX_ENVSTR, "HOME=%s", pw-&amp;gt;pw_dir);
                if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
--
        if (!env_get("PATH", e-&amp;gt;envp)) {
                snprintf(envstr, MAX_ENVSTR, "PATH=%s", _PATH_DEFPATH);
                if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
--
        }
        snprintf(envstr, MAX_ENVSTR, "%s=%s", "LOGNAME", pw-&amp;gt;pw_name);
        if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
--
#if defined(BSD)
        snprintf(envstr, MAX_ENVSTR, "%s=%s", "USER", pw-&amp;gt;pw_name);
        if ((tenvp = env_set(e-&amp;gt;envp, envstr))) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分別設定了 &lt;code&gt;SHELL&lt;/code&gt;、&lt;code&gt;HOME&lt;/code&gt;、&lt;code&gt;PATH&lt;/code&gt; 和 &lt;code&gt;LOGNAME&lt;/code&gt;，這 4 的變數和上述用 &lt;code&gt;ps&lt;/code&gt; 所觀測的環境變數，&lt;code&gt;SHELL=/bin/sh HOME=/root PATH=/usr/bin:/bin LOGNAME=root&lt;/code&gt;，其結果是完全吻合的。&lt;/p&gt;

&lt;p&gt;至此，真相大白。&lt;/p&gt;

&lt;h1 id="後記"&gt;後記&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;本文中的 cron 指的是大多數人所使用的 vixie cron，如果是 busybox 的實作則不會出現這個問題，在 busybox 裡面，cron 工作的程序環境變數會繼承父程序。&lt;/li&gt;
  &lt;li&gt;感謝吾友 @floydwch 提出的問題，使筆者學到不少知識。&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ruby 自動載入器</title>
    <link rel="alternate" href="https://tonytonyjan.net/2018/04/22/ruby-autoloader/"/>
    <id>https://tonytonyjan.net/2018/04/22/ruby-autoloader/</id>
    <published>2018-04-22T16:23:00+08:00</published>
    <updated>2018-04-23T09:42:27+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;軟體在載入模組的方式，可大致分為兩種：消極載入（lazy loading） 與積極載入（eager loading）&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。顧名思義，消極載入是指軟體在啟動時僅載入少數需要的模組，而在執行過程如果有需要其他模組時，再載入該需要的模組；反之積極載入則是在軟體啟動時，積極地將所有的模組載入。&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;軟體在載入模組的方式，可大致分為兩種：消極載入（lazy loading） 與積極載入（eager loading）&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。顧名思義，消極載入是指軟體在啟動時僅載入少數需要的模組，而在執行過程如果有需要其他模組時，再載入該需要的模組；反之積極載入則是在軟體啟動時，積極地將所有的模組載入。&lt;/p&gt;



&lt;p&gt;兩者各有優缺點，一般會在消極載入由於啟動速度快，常用在開發環境（development environment）中，缺點則是軟體運作過程中，對於首次執行的任務，因得加上載入的時間導致效率較差，這在生產環境（production environment）不見得是好事。所以在消極載入的設計下，有些人會在部署時加上一道暖身（warn up）的步驟，以部署一台網頁伺服器為例，可能會在部署後送出各種超文本傳輸協定的請求到上線伺服器，以被動的方式使其可以預先載入所需的模組。積極載入的優缺點則相反：運行快但啟動慢，所以一般會用在生產環境。&lt;/p&gt;

&lt;p&gt;一個比較現代的開發方式是針對載入模組的工作額外設計一個載入器，這個載入器可以在積極或消極兩者間做切換，以在開發環境中使用消極載入，生產環境中使用積極載入。&lt;/p&gt;

&lt;h1 id="const_missing-vs-moduleautoload"&gt;const_missing v.s. Module.autoload&lt;/h1&gt;

&lt;p&gt;&lt;a href="http://guides.rubyonrails.org/autoloading_and_reloading_constants.html"&gt;Rails Guide 有一個篇章&lt;/a&gt;詳細介紹了 Rails 內部載入的方法。內文提到 Rails 在消極載入的實作並沒有使用到 Ruby 內建的 &lt;code&gt;Module.autoload&lt;/code&gt;，取而代之則是用 &lt;code&gt;const_missing&lt;/code&gt; 來實作。&lt;/p&gt;

&lt;p&gt;雖然使用 ActiveSupport 的載入器可以省不少麻煩，但筆者沒有需要用到像是熱重載這類進階功能，加上覺得 &lt;code&gt;const_missing&lt;/code&gt; 效能上並沒有比用 &lt;code&gt;Module.autoload&lt;/code&gt; 實作來的好，只是到底會慢多少？筆者寫了一個基準測試（benchmark test）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;# frozen_string_literal: true

require 'bundler/setup'
require 'benchmark'
require 'fileutils'
require 'active_support' # v5.2.0
require_relative 'autoloader'

n = 10000
words = (?a..?z).to_a.permutation(5).lazy.map(&amp;amp;:join).first(n)
class_names = words.map(&amp;amp;:capitalize)
FileUtils.rm_rf %w[as al]
FileUtils.mkdir_p 'as/foo'
FileUtils.mkdir_p 'al/bar'
words.each do |word|
  IO.write "as/foo/#{word}.rb", "module Foo; module #{word.capitalize} end end"
  IO.write "al/bar/#{word}.rb", "module Bar; module #{word.capitalize} end end"
end

Benchmark.bm(13) do |x|
  ActiveSupport::Dependencies.autoload_paths = ['as']
  x.report('ActiveSupport') do
    class_names.each do |class_name|
      eval "Foo::#{class_name}"
    end
  end

  IO.write 'al/bar.rb', 'module Bar; include Autoloader end'
  require_relative 'al/bar'
  x.report('Autoloader') do
    class_names.each do |class_name|
      eval "Bar::#{class_name}"
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;autoloader&lt;/code&gt; 是筆者另外寫的載入器，載入的檔案是動態產生的，分別放在 &lt;code&gt;as&lt;/code&gt; 和 &lt;code&gt;al&lt;/code&gt; 資料夾，&lt;code&gt;as&lt;/code&gt; 裡的檔案給 ActiveSupport 載入，&lt;code&gt;al&lt;/code&gt; 裡的則以筆者的自製的載入器載入。&lt;/p&gt;

&lt;p&gt;再來看看結果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user     system      total        real
ActiveSupport  16.810000   1.320000  18.130000 ( 18.128572)
Autoloader      1.170000   0.630000   1.800000 (  1.804112)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起來 Autoloader 大約比 ActiveSupport 的版本要快上 10 倍。以下是 &lt;code&gt;autoloader.rb&lt;/code&gt; 的原始碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;module Autoloader
  def self.included(mod)
    caller_path, = caller(1..1).first.partition(':')
    pattern = "#{File.dirname(caller_path)}/#{File.basename(caller_path, '.rb')}/*.rb"
    Dir.glob(pattern).each do |path|
      class_name = File.basename(path, '.rb').split('_').map(&amp;amp;:capitalize).join.to_sym
      mod.autoload class_name, path
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="筆者的-autoloader-的慣例"&gt;筆者的 Autoloader 的慣例&lt;/h1&gt;

&lt;p&gt;筆者的 Autoloader 雖然以效能為出發點，但使用上有些限制。由於它沒有像是 ActiveSupport 會自動將資料夾轉為 module 的&lt;del&gt;魔法&lt;/del&gt;功能（例如有個空的資料夾 &lt;code&gt;foo/bar&lt;/code&gt;，當引用 &lt;code&gt;Foo::Bar&lt;/code&gt; 時，即便沒有 &lt;code&gt;foo/bar.rb&lt;/code&gt;，&lt;code&gt;module Bar; end&lt;/code&gt; 也會自動產生），所以針對每個層級的資料夾，都需要有一個同級同名的檔案來定義名稱空間，例如以下的檔案結構為例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lib
├── myapp
│   ├── adapters
│   │   ├── foo.rb
│   │   ├── bar.rb
│   │   └── buz.rb
│   ├── adapters.rb
│   ├── entities
│   │   ├── foo.rb
│   │   ├── bar.rb
│   │   └── buz.rb
│   ├── entities.rb
│   ├── interactors
│   │   ├── foo.rb
│   │   ├── bar.rb
│   │   └── buz.rb
│   └── interactors.rb
└── myapp.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而其中 &lt;code&gt;adapters&lt;/code&gt; 資料夾相對應 &lt;code&gt;adapters.rb&lt;/code&gt; 原始碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;module Myapp
  module Adapters
    include Autoloader
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同於：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;module Myapp
  module Adapters
    autoload :Foo, "#{__dir__}/foo.rb"
    autoload :Bar, "#{__dir__}/bar.rb"
    autoload :Buz, "#{__dir__}/buz.rb"
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="積極載入"&gt;積極載入&lt;/h1&gt;

&lt;p&gt;筆者尚未對 Autoloader 於生產環境做過優化，但理論上不至於太困難，一個作法是在 &lt;code&gt;autoloader.rb&lt;/code&gt; 裡面可以加入環境變數來判斷如何載入：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;if ENV['MYAPP_ENV'] == 'production'
  Kernel.require path
else
  mod.autoload class_name, path
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在 &lt;code&gt;Autoloader&lt;/code&gt; 模組裡面提供載入方法的介面：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class Foo
  include Autoloader
  ENV['MYAPP_ENV'] == 'production' ? eager_load! : lazy_load!
end
&lt;/code&gt;&lt;/pre&gt;

&lt;div class="footnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1"&gt;
      &lt;p&gt;也有翻譯叫「惰性載入」、「懶載入」，另一邊則稱「熱情載入」等，但筆者認為兩者概念應該透過「消極」與「積極」這樣的翻譯最能融入當地的用語且能一目了然。 &lt;a href="#fnref:1" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>我的貓 - 黏黏和歲歲</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/12/29/my-cat/"/>
    <id>https://tonytonyjan.net/2016/12/29/my-cat/</id>
    <published>2016-12-29T16:58:00+08:00</published>
    <updated>2018-04-22T16:49:27+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;似乎從來沒有介紹過家裡的貓，索性來出賣幾張照片吧！&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161110.jpg" alt=""&gt;&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;似乎從來沒有介紹過家裡的貓，索性來出賣幾張照片吧！&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161110.jpg" alt="" /&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src="/images/cats/20160911-2.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20160911.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161203.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161027.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161004.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/cats/20161007.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;筆者自 2015 十月開始認養第一隻貓咪，2016 六月認養第二隻，由於從小到大沒有養寵物的經驗，不知從和開始，前三個月不是四處問人就是不斷上網找資料。好在中途之家的姊姊很熱心，總是親切地回答我的問題。&lt;/p&gt;

&lt;h2 id="飲食"&gt;飲食&lt;/h2&gt;

&lt;p&gt;因為知道了近幾年台灣開始吹起了濕食風，遂一開始就沒有打算買乾飼料，就先從三餐吃罐頭開始。試過了顛峰、鈕翠寶、Goody 等等。最後是顛峰的口性最好，雖然顛峰不便宜，當時筆者才養一隻貓，負擔尚可，但第二隻住進來後有些吃緊，筆者也開始找其他濕食管道。&lt;/p&gt;

&lt;p&gt;後來知道台灣有幾家廠商有在做寵物生食，像是汪喵、巴夫等，索性買了一條回家嘗試，不料家裡主子愛吃到把整個碗舔地乾乾淨淨，筆者心喜之下果斷買了幾箱。&lt;/p&gt;

&lt;p&gt;就這樣，她們之後都吃生肉，回歸原始的飲食，而不是加工過的罐頭。&lt;/p&gt;

&lt;h2 id="健康"&gt;健康&lt;/h2&gt;

&lt;p&gt;只有姊姊黏黏看過病，剛來筆者家裡第一天就發燒了。初養前十天就要照顧病貓，這對第一次養寵物的人來說實在是一件很困難的事，但也因此筆者在剛養貓的第一個禮拜就學會了投藥的技能，記得第一次投藥前看了十幾部 YouTube 教學影片，就怕自己做錯一步，害到了黏黏。&lt;/p&gt;

&lt;h2 id="娛樂"&gt;娛樂&lt;/h2&gt;

&lt;p&gt;本來以為只要是逗貓棒就可以吸引貓咪，但好像還是得看個性才行。歲歲會為了彩帶棒瘋狂，但黏黏對貓草娃娃比較感興趣，這讓筆者每次選購玩具都會考慮買到兩種以上。&lt;/p&gt;

&lt;p&gt;根據觀察，貓似乎無法分辨棉被和床中間有一層空間，或是無法理解筆者蓋上被子是什麼概念，每次筆者埋進一隻手在棉被裡搓出一點聲音，她們就會開始隔著棉被狩獵筆者的手，好氣又好笑。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;養寵物真的事很棒的一件事，尤其是對獨居太久的人，加上如果工作性質又屬於 SOHO 的話，長久下來真的會生病，有個寵物陪在身邊，生活也比較不會憂鬱。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby#open 知多少？</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/06/15/comparison-of-ruby-open/"/>
    <id>https://tonytonyjan.net/2016/06/15/comparison-of-ruby-open/</id>
    <published>2016-06-15T00:12:00+08:00</published>
    <updated>2018-04-22T16:49:27+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文同步發表於 &lt;a href="https://blog.alphacamp.co/2016/06/30/ruby-open/"&gt;alphacamp&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/io.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;先來個快問快答吧：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果現在要你使用 Ruby 去開檔，你會想到怎麼做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直覺是使用 &lt;code&gt;File.open&lt;/code&gt;，但想想 &lt;code&gt;File.new&lt;/code&gt; 似乎也可行，然後又發現不使用 &lt;code&gt;File&lt;/code&gt; 類別，直接用 &lt;code&gt;open&lt;/code&gt; 也能做到一樣的事。去查了 Ruby 文件結果...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;strong&gt;本文同步發表於 &lt;a href="https://blog.alphacamp.co/2016/06/30/ruby-open/"&gt;alphacamp&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/io.jpg" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;先來個快問快答吧：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果現在要你使用 Ruby 去開檔，你會想到怎麼做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直覺是使用 &lt;code&gt;File.open&lt;/code&gt;，但想想 &lt;code&gt;File.new&lt;/code&gt; 似乎也可行，然後又發現不使用 &lt;code&gt;File&lt;/code&gt; 類別，直接用 &lt;code&gt;open&lt;/code&gt; 也能做到一樣的事。去查了 Ruby 文件結果發現 &lt;code&gt;IO.open&lt;/code&gt; 和 &lt;code&gt;IO.new&lt;/code&gt; 也能做到同樣的操作。&lt;/p&gt;

&lt;p&gt;如你所見，使用 Ruby 光是開個&lt;a href="https://zh.wikipedia.org/zh-tw/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"&gt;檔案描述符&lt;/a&gt;（以下簡稱 FD）就有數幾種方法，令人眼花撩亂，常看到的是有人用同一招打天下，卻一直沒有去了解其他的方法與其是用情境，有些可惜，而這篇文章將透過由下而上的方式，一一介紹、示範它們的差別和使用。&lt;/p&gt;

&lt;h1 id="ionew"&gt;IO.new&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;IO&lt;/code&gt; 類別是 Ruby 對 FD 進行讀寫操作的一切基礎，我們可以用 &lt;code&gt;File&lt;/code&gt; 來操作是因為 &lt;code&gt;File&lt;/code&gt; 繼承自 &lt;code&gt;IO&lt;/code&gt;，只是稍嫌麻煩些。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IO.new&lt;/code&gt; 的第一個參數必須是 FD，或在 Windows 下則稱 &lt;a href="https://zh.wikipedia.org/zh-hant/%E5%8F%A5%E6%9F%84"&gt;句柄&lt;/a&gt;，無論何者都只是一個數字。&lt;/p&gt;

&lt;p&gt;如果你已知標準輸入與標準輸出的檔案描述符分別為 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt;，不妨實驗一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;stdin = IO.new(0)
stdout = IO.new(1)
stdout.puts "what's your name?"
name = stdin.gets.chomp!
stdout.puts "hello, #{name}!"

# what's your name?
# tony
# hello, tony!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外可用 &lt;code&gt;IO.sysopen&lt;/code&gt; 來取得檔案的 FD，這其實就是 &lt;code&gt;File&lt;/code&gt; 類別的做法，&lt;code&gt;File&lt;/code&gt; 只是隱藏此細節罷了：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;fd = IO.sysopen('file.txt', 'w') #=&amp;gt; 3
io = IO.new(fd)
io.puts 'hello!'
io.close
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一個例子是透過 &lt;code&gt;/dev/tty&lt;/code&gt; 寫到終端：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;fd = IO.sysopen('/dev/tty', 'w')
io = IO.new(fd,'w')
puts 'Hello'
io.puts 'World'
io.close

# Hello
# World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;筆者在這裡提醒要小心選擇正確的 tty 檔案，萬一不慎選到其他使用者的，執行上述程式碼就會在他人的終端畫面上印出一堆垃圾。&lt;/p&gt;

&lt;p&gt;如果對 tty 的概念不熟悉，可以參考&lt;a href="http://tldp.org/HOWTO/Text-Terminal-HOWTO-7.html"&gt;這篇文章&lt;/a&gt;，在 UN*X 的世界裡面，所有裝置都是一個檔案，終端也是一個檔案，自然可以像檔案一樣對其進行讀寫。&lt;/p&gt;

&lt;h1 id="ioopen"&gt;IO.open&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;IO.open&lt;/code&gt; 沒什麼新奇之處，它只是 &lt;code&gt;IO.new&lt;/code&gt; 加上 block 的擴充版本，若無使用 block 時，與 &lt;code&gt;IO.new&lt;/code&gt; 無異，最後會回傳 &lt;code&gt;IO&lt;/code&gt; 物件；但若與 block 使用，有兩個特點：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;IO&lt;/code&gt; 物件會在 block 結束時被自動關閉（意即不需要寫 &lt;code&gt;IO#close&lt;/code&gt;）。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IO.open&lt;/code&gt; 最後回傳的不再是 &lt;code&gt;IO&lt;/code&gt; 物件，而是 block 的最後執行結果。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id="iopopen"&gt;IO.popen&lt;/h1&gt;

&lt;p&gt;有曾好奇過市面上的 CI 是怎麼做到即時顯示終端上的文字嗎？以 Travis CI 為例，下圖那塊黑色區塊中的內容是即時輸出的：&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/travis.png" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;或者曾想過在自己的網站上執行外部的指令，並且即時呈現給使用者呢？若你有在 Ruby 中呼叫其他系統指令的經驗（例如 &lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;cat&lt;/code&gt;、&lt;code&gt;bundle install&lt;/code&gt; 等等），那應該對 &lt;code&gt;system&lt;/code&gt;、&lt;code&gt;%x{}&lt;/code&gt; 或是 &lt;code&gt;``&lt;/code&gt; 不陌生：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;system 'date' # =&amp;gt; true, false or nil
%x{date}      # =&amp;gt; the standard output of the running cmd
`date`        # =&amp;gt; as above
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而 &lt;code&gt;system&lt;/code&gt; 只根據指令執行結果成功與否回傳布林值，無法直接存取子程序輸出的結果；&lt;code&gt;%x{}&lt;/code&gt; 會以字串形式回傳結果，但必須等到子程序執行結束後才會回傳整個字串，無法即時監控子程序的標準輸出。&lt;/p&gt;

&lt;p&gt;相較於 &lt;code&gt;%x{}&lt;/code&gt; 回傳完整的字串，&lt;code&gt;IO.popen&lt;/code&gt; 則是回傳 &lt;code&gt;IO&lt;/code&gt; 物件。為了比較出差異，這裡就拿 &lt;code&gt;ping&lt;/code&gt; 指令為例，因為該指令會不斷在終端畫面上輸出訊息，直到使用者手動停止，如果使用 &lt;code&gt;%x{}&lt;/code&gt; 的話，Ruby 程式將會卡在該處，且因準備要回傳的字串越來越長，最後導致記憶體不夠用或程式會卡到海枯石爛。&lt;/p&gt;

&lt;p&gt;相較下操作 &lt;code&gt;IO&lt;/code&gt; 物件就可以一次讀一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;# puts %x{ping www.alphacamp.co} # don't do this
io = IO.popen('ping www.alphacamp.co')
while line = io.gets
  print line
end
# PING www.alphacamp.co (198.41.206.122): 56 data bytes
# 64 bytes from 198.41.206.122: icmp_seq=0 ttl=58 time=2.794 ms
# 64 bytes from 198.41.206.122: icmp_seq=1 ttl=58 time=4.876 ms
# 64 bytes from 198.41.206.122: icmp_seq=2 ttl=58 time=7.081 ms
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;當然這還離真正做出一個在網頁上呈現終端執行畫面的功能還很遠，例如上述的程式碼卡在一個無窮迴圈裡面，&lt;br /&gt;
你可能會想針對 IO 阻塞問題做出一些改善，像是配合 &lt;code&gt;IO.select&lt;/code&gt; 或是 &lt;code&gt;IO#read_nonblock&lt;/code&gt; 等，但純屬延伸議題，不在本章範圍，有機會筆者會在另一篇章中分享怎麼做到 :)&lt;/p&gt;

&lt;h1 id="filenew-與-fileopen"&gt;File.new 與 File.open&lt;/h1&gt;

&lt;p&gt;這兩個方方法就是大家耳熟能詳的開檔方案了，它們和 &lt;code&gt;IO.new&lt;/code&gt; 與 &lt;code&gt;IO.open&lt;/code&gt; 幾乎一樣，只差在覆寫了 &lt;code&gt;initialize&lt;/code&gt; 方法，使其接受的參數不再是 FD 而是檔案的路徑字串。&lt;code&gt;File.new&lt;/code&gt; 回傳值也和 &lt;code&gt;IO.new&lt;/code&gt; 一樣是 &lt;code&gt;IO&lt;/code&gt; 物件；在 &lt;code&gt;File.open&lt;/code&gt; 與 block 同時使用的情況下也和 &lt;code&gt;IO.open&lt;/code&gt; 一樣，會自動關檔，且回傳 block 的最後執行結果。&lt;/p&gt;

&lt;h1 id="kernelopen"&gt;Kernel.open&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Kernel.open&lt;/code&gt; 大概是最萬用的方法了，留在最後講是因為它是 &lt;code&gt;IO.popen&lt;/code&gt; 與 &lt;code&gt;File.open&lt;/code&gt; 的合體，除此也接受擁有 &lt;code&gt;#to_open&lt;/code&gt; 方法的物件。&lt;/p&gt;

&lt;p&gt;當傳入一個物件給 &lt;code&gt;Kernel.open&lt;/code&gt; 時，處理的優先續如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;檢查該物件是否有 &lt;code&gt;#to_open&lt;/code&gt; 方法，有則直接呼叫以取得 &lt;code&gt;IO&lt;/code&gt; 物件。&lt;/li&gt;
  &lt;li&gt;如果物件是字串且開頭是 &lt;code&gt;|&lt;/code&gt;，則去掉 &lt;code&gt;|&lt;/code&gt;，剩下丟給 &lt;code&gt;IO.popen&lt;/code&gt; 處理。&lt;/li&gt;
  &lt;li&gt;最後交給 &lt;code&gt;File.open&lt;/code&gt; 處理&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="to_open"&gt;to_open&lt;/h2&gt;

&lt;p&gt;關於 &lt;code&gt;#to_open&lt;/code&gt; Ruby 文件上沒有一處提及，只記載在 Ruby 原始碼中。實作的時候必要回傳 &lt;code&gt;IO&lt;/code&gt; 物件即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;class Foo
  def to_open
    puts 'Foo#to_open is here'
    File.open('test.txt') # =&amp;gt; IO instance
  end
end

open Foo.new do |io|
  # ...
  # io will be closed automatically
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="該用哪個"&gt;該用哪個？&lt;/h1&gt;

&lt;p&gt;這沒有什麼強制的規範，畢竟 Ruby 是一個自由的程式語言，比較接近 Perl，和一板一眼的 Python 不太一樣（Only one way to do it）。不過筆者建議大原則是盡量使用易讀易寫的 API 來完成工作，如果有細節需要處理再用其他的方法。例如一般開檔就使用 &lt;code&gt;File.open&lt;/code&gt; 或是 &lt;code&gt;Kernel.open&lt;/code&gt; 即可，需要存取 FD 則改用 &lt;code&gt;IO.open&lt;/code&gt;，若要手動關檔再考慮 &lt;code&gt;File.new&lt;/code&gt; 或 &lt;code&gt;IO.new&lt;/code&gt;。另外也不要特別使用 &lt;code&gt;Kernel.open&lt;/code&gt; 調用 &lt;code&gt;IO.popen&lt;/code&gt; 的奇怪語法（&lt;code&gt;|&lt;/code&gt;），這會降低程式碼的可讀性，不符合易讀易寫。像 &lt;code&gt;IO.popen('date')&lt;/code&gt; 就比 &lt;code&gt;Kernel.open('|date')&lt;/code&gt; 好懂多了。&lt;/p&gt;

&lt;p&gt;另一個原則是程式碼的一致性，如果團隊開檔案都使用 &lt;code&gt;File.open&lt;/code&gt;，那就盡量避免特立獨行使用 &lt;code&gt;Kernel.open&lt;/code&gt;，反之亦然。&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>Ziltag Beta 啟動</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/03/01/ziltag-start/"/>
    <id>https://tonytonyjan.net/2016/03/01/ziltag-start/</id>
    <published>2016-03-01T00:53:00+08:00</published>
    <updated>2018-04-22T16:49:27+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;筆者很久以前曾希望有個服務可以在圖片上自由的加上各種資訊，那是在看漫畫的時候，心想如果可以在某些分鏡加上自己的評論並與網友們互動，效果應該不錯，不料今天出自夥伴與自己的手，世事難料啊XD&lt;/p&gt;

&lt;h1 id="zillion-tags-ziltag"&gt;Zillion Tags, Ziltag&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://ziltag.com"&gt;Ziltag&lt;/a&gt; 的目的是希望在現有的圖片、影片等多媒體上面，創要一種新的社交互動方式：你可以在任何圖片的任何地方標籤上任何資訊，可以是一句話、一個人名、一段連結影片等，而每個標籤都可以是個討論串。&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;筆者很久以前曾希望有個服務可以在圖片上自由的加上各種資訊，那是在看漫畫的時候，心想如果可以在某些分鏡加上自己的評論並與網友們互動，效果應該不錯，不料今天出自夥伴與自己的手，世事難料啊XD&lt;/p&gt;

&lt;h1 id="zillion-tags-ziltag"&gt;Zillion Tags, Ziltag&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://ziltag.com"&gt;Ziltag&lt;/a&gt; 的目的是希望在現有的圖片、影片等多媒體上面，創要一種新的社交互動方式：你可以在任何圖片的任何地方標籤上任何資訊，可以是一句話、一個人名、一段連結影片等，而每個標籤都可以是個討論串。&lt;/p&gt;



&lt;p&gt;如果你的設備有滑鼠指標（Beta 尚未支援手機），只要將它移動到下面這張圖片就可以理解這個服務在做什麼：&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/piano.jpg" alt="tonytonyjan is playing the piano" /&gt;&lt;/p&gt;

&lt;p&gt;有別於其他平台，Ziltag 是以提供腳本的方式給那些想要在網站上提供多元互動的站長們使用，這些站長們可能是部落客、攝影師、畫家、設計師、美食家、探險家等。除了創造與讀者的新互動之外，他們也能透過標籤傳達讀者可能感興趣的資訊，例如商品的價錢、植物的介紹、食材廣告、英語單字教學等等，使用方式依照使用者的創意可以十分多元。&lt;/p&gt;

&lt;h1 id="成為-ziltag-夥伴"&gt;成為 Ziltag 夥伴&lt;/h1&gt;

&lt;p&gt;成為使用者很容易，當你在聆聽筆者的音樂拙作時，就已經是 Ziltag 使用者了，如果想進一步留下評語（手下留情），直接留言即可，並不需要離開筆者的網站。相對的，你若有自己的網站，且也希望提供你的讀者不同的體驗，則必須透過 &lt;a href="https://ziltag.com"&gt;Ziltag&lt;/a&gt; 網站註冊並索取腳本，不妨今天就來玩玩看吧 :)&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>Rails on webpack</title>
    <link rel="alternate" href="https://tonytonyjan.net/2016/02/10/rails-on-webpack/"/>
    <id>https://tonytonyjan.net/2016/02/10/rails-on-webpack/</id>
    <published>2016-02-10T22:35:00+08:00</published>
    <updated>2018-04-22T16:49:27+08:00</updated>
    <author>
      <name>大兜</name>
    </author>
    <summary type="html">&lt;p&gt;記得筆者在去年於 RubyConf Taiwan 講的題目「&lt;a href="https://youtu.be/0mphTtsekkI?t=2m59s"&gt;還給前端工程師一片天空&lt;/a&gt;」中提到如何整合 Rails 與 Node.js 世界的工具，&lt;a href="/slides/2015-09-11-return-front-end-back-to-front-end-developers/slides.pdf"&gt;投影片在此&lt;/a&gt;。雖然 &lt;a href="https://github.com/webpack/webpack"&gt;webpack&lt;/a&gt; 正夯，但礙於筆者當時沒去研究，使用的工具仍是上一代的 gulp、bower，所幸議程也有相關的講題，如&lt;strong&gt;何澤清&lt;/strong&gt;前輩的「&lt;a href="https://www.youtube.com/watch?v=vbdVuEctCCQ"&gt;gem 'webpack-rails'&lt;/a&gt;」。&lt;/p&gt;

&lt;p&gt;只是經過筆者幾番研究之後，覺得整合這兩樣東西似乎不需要像網路上找到的各種教學文或是 gem 搞的那樣複雜，所以想藉這篇文章分享自己的做法（但並不保留 sprockets）。在那之前，先分享一些小知識：&lt;/p&gt;

</summary>
    <content type="html">&lt;p&gt;記得筆者在去年於 RubyConf Taiwan 講的題目「&lt;a href="https://youtu.be/0mphTtsekkI?t=2m59s"&gt;還給前端工程師一片天空&lt;/a&gt;」中提到如何整合 Rails 與 Node.js 世界的工具，&lt;a href="/slides/2015-09-11-return-front-end-back-to-front-end-developers/slides.pdf"&gt;投影片在此&lt;/a&gt;。雖然 &lt;a href="https://github.com/webpack/webpack"&gt;webpack&lt;/a&gt; 正夯，但礙於筆者當時沒去研究，使用的工具仍是上一代的 gulp、bower，所幸議程也有相關的講題，如&lt;strong&gt;何澤清&lt;/strong&gt;前輩的「&lt;a href="https://www.youtube.com/watch?v=vbdVuEctCCQ"&gt;gem 'webpack-rails'&lt;/a&gt;」。&lt;/p&gt;

&lt;p&gt;只是經過筆者幾番研究之後，覺得整合這兩樣東西似乎不需要像網路上找到的各種教學文或是 gem 搞的那樣複雜，所以想藉這篇文章分享自己的做法（但並不保留 sprockets）。在那之前，先分享一些小知識：&lt;/p&gt;



&lt;h1 id="asset_path-知多少"&gt;asset_path 知多少？&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;#asset_path&lt;/code&gt; 是 Rails 中其中一個底層 API，許多 helper 如 &lt;code&gt;#image_tag&lt;/code&gt; 等都會調用，而若沒有特別查閱原始碼，大概不多人知道 &lt;code&gt;asset_path('/app.js')&lt;/code&gt; 和 &lt;code&gt;asset_path('app.js')&lt;/code&gt; 差了一個斜線會影響結果，至於差在哪就讓我們節錄部份原始碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;def asset_path(source, options = {})
  # ...
  if source[0] != ?/
    source = compute_asset_path(source, options)
  end
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sprockets 其實有偷偷去複寫 &lt;code&gt;#compute_asset_path&lt;/code&gt;，也就是說當傳入 &lt;code&gt;"/app.js"&lt;/code&gt;，assets pipeline 是不會運作的，但若傳入 &lt;code&gt;"app.js"&lt;/code&gt;，在 sprockets &lt;code&gt;#compute_asset_path&lt;/code&gt; 的加持下結果會長的像 &lt;code&gt;/assets/app-c5bd5cb45ee76432b26a5dfb28e01b59.js?body=1&lt;/code&gt;；反之若 &lt;code&gt;"app.js"&lt;/code&gt; 檔案不存在，或者根本就沒安裝 sprockets，那就退回原型得到 &lt;code&gt;"/app.js"&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以只要我們複寫的 &lt;code&gt;#compute_asset_path&lt;/code&gt; 能算出 webpack 產生在 &lt;code&gt;public/assets&lt;/code&gt; 中的正確路徑，其實不用更改任何 API，就可以輕鬆整合 webpack。而 &lt;code&gt;#javascript_include_tag&lt;/code&gt;、&lt;code&gt;#stylesheet_link_tag&lt;/code&gt;、&lt;code&gt;#image_tag&lt;/code&gt; 等 helper 都可以照常使用。&lt;/p&gt;

&lt;h1 id="webpack-json"&gt;webpack –json&lt;/h1&gt;

&lt;p&gt;sprockets 在編譯後會產生 &lt;code&gt;manifest.json&lt;/code&gt;，裡面有 asset 原始路徑與其計算後的路徑資訊（例如 &lt;code&gt;app.js&lt;/code&gt; 對應到 &lt;code&gt;/assets/app-c5bd5cb45ee76432b26a5dfb28e01b59.js&lt;/code&gt;，以 Hash 儲存），好處是 Rails 可以透過讀檔取得計算後的路徑結果，不須透過 sprockets，所以為了增加效能，這個檔案在 production 環境中是必要的，而在 development 環境中，由於 assets 的路徑是及時透過 sprockets 得出，所以並不需要這個檔案。&lt;/p&gt;

&lt;p&gt;此外 sprockets 在 controller 與 router 中也動了手腳，這也是為什麼專案中 &lt;code&gt;public/assets&lt;/code&gt; 明明沒東西，而在 development 環境下中送出像是 &lt;code&gt;/assets/ooxx.js&lt;/code&gt; 的請求卻仍可以正常運作的原因。&lt;/p&gt;

&lt;p&gt;只是 webpack 畢竟是 Node.js 世界的產物，無法篡改 Rails controller 與 router，好消息是 &lt;code&gt;webpack --json&lt;/code&gt; 會產生一個跟 &lt;code&gt;manifest.json&lt;/code&gt; 類似的檔案（官方稱之為 stats file）。所以只要在 &lt;code&gt;webpack.config.js&lt;/code&gt; 中加入產生 stats 的 plugin，再用 &lt;code&gt;webpack --watch&lt;/code&gt; 來開發就已經綽綽有餘了，例如我們在專案的根目錄下產生 &lt;code&gt;stats.json&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-js"&gt;plugins = [
  function() {
    this.plugin('done', function(stats) {
      require('fs').writeFileSync(__dirname + '/stats.json', JSON.stringify(stats.toJson()))
    })
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="範例專案"&gt;範例專案&lt;/h1&gt;

&lt;p&gt;筆者&lt;a href="https://github.com/tonytonyjan/rails_on_webpack"&gt;在 Github 實作了一個範例&lt;/a&gt;，重點只在兩個檔案： &lt;a href="https://github.com/tonytonyjan/rails_on_webpack/blob/master/app/helpers/webpack_helper.rb"&gt;app/helpers/webpack_helper.rb&lt;/a&gt; 與 &lt;a href="https://github.com/tonytonyjan/rails_on_webpack/blob/master/lib/webpack_stats.rb"&gt;lib/webpack_stats.rb&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack_stats.rb&lt;/code&gt; 負責載入 webpack 產生的 &lt;code&gt;stats.json&lt;/code&gt;，經過處理之後產生一個 assets hash，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;{
  'app.js' =&amp;gt; '/assets/app.js',
  'app.css' =&amp;gt; '/assets/app-c5bd5cb45ee76432b26a5dfb28e01b59.css' # 也支援 hash 尾綴
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（限制是 webpack 必須遵守檔名格式為 &lt;code&gt;filename-hash.extname&lt;/code&gt; 或是 &lt;code&gt;filename.extname&lt;/code&gt;。）&lt;/p&gt;

&lt;p&gt;而這個 assets hash 將被用在 &lt;code&gt;#compute_asset_path&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;# app/helpers/webpack_helper.rb
require 'webpack_stats'
module WebpackHelper
  def compute_asset_path source, options = {}
    WebpackStats.assets[source] || super
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大功告成！老實說這樣就已經能完美運作了，不用安裝什麼 gem，實測用來寫 react 也不用安裝 &lt;a href="https://github.com/reactjs/react-rails"&gt;react-rails&lt;/a&gt;。而剩下的問題已經不關整合的事，像要加入 SASS、CoffeeScript 或是 Font Awesome 等，或是在 production 下要壓縮 JavaScript 並且分離 CSS 檔案等，這取決開發者對 webpack 的掌握。&lt;/p&gt;

&lt;p&gt;至於只在 production 中分離 CSS 檔案，裡面可以這樣寫：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;%= stylesheet_link_tag 'application', media: 'all' if Rails.env.production? %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至於為何要這樣做，可參考 extract-text-webpack-plugin 的 &lt;a href="https://github.com/webpack/extract-text-webpack-plugin/blob/master/README.md"&gt;README&lt;/a&gt; 提到的優缺點。&lt;/p&gt;

&lt;h1 id="我就是要-gem"&gt;我就是要 gem&lt;/h1&gt;

&lt;p&gt;其實筆者也是有做啦⋯⋯如果真的覺得那兩個檔案很麻煩，可以安裝 &lt;a href="https://github.com/tonytonyjan/webpack_stats"&gt;webpack_stats&lt;/a&gt;，這除了可以用在 Rails，也可以當一般 webpack stats 的 loader 使用（用在 Rails 之外的地方）。&lt;/p&gt;
</content>
  </entry>
</feed>
